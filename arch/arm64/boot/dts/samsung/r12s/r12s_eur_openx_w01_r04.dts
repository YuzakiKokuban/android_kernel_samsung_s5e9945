
/*
 * Copyright (c) 2018 Samsung Electronics Co., Ltd.
 *              http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
*/

/dts-v1/;
/plugin/;
/ {
	fragment@smd {
		target-path = "/";
		__overlay__ {
			smd: samsung_mobile_device {
				compatible = "simple-bus";
			};
		};
	};
};

/* #include "../display_ana6710_a55x.dtsi" */        /* From display_ana6710_a55x.py */
/*
 * Samsung Exynos SoC series Panel driver
 *
 * Copyright (c) 2020 Samsung Electronics Co., Ltd
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <dt-bindings/display/panel-display.h>
#include <dt-bindings/display/exynos-display.h>
#include "../display_ana6710_a55x_adaptive_mipi.dtsi"

&dsim_modes {
	1080x2340@120hs {
		exynos,pmsk = <
			0x05 0x90 0x01 0x4555 /* p m s k */
			0x00 0x00 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1108>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <2188>;
	};
	1080x2340@60phs {
		exynos,pmsk = <
			0x05 0x90 0x01 0x4555 /* p m s k */
			0x00 0x00 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1108>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <2188>;
	};
	1080x2340@60hs {
		exynos,pmsk = <
			0x05 0x90 0x01 0x4555 /* p m s k */
			0x00 0x00 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1108>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <7902>;
	};
	1080x2340@30ns {
		exynos,pmsk = <
			0x05 0x90 0x01 0x4555 /* p m s k */
			0x00 0x00 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1108>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <19330>;
	};
};

&drmdsim_0 {
	hs_pll_timing = <&dsim_hs_pll_timing>;
};

/ {
	fragment@panel_display_mode {
		target-path = "/";
		__overlay__ {
			a55x_ana6710_panel_display_modes:
			a55x_ana6710_panel_display_modes {
				native-mode = <&a55x_ana6710_panel_display_mode_1080x2340_120hs>;
				exposed-mode = <
					&a55x_ana6710_panel_display_mode_1080x2340_120hs
					&a55x_ana6710_panel_display_mode_1080x2340_60phs
					&a55x_ana6710_panel_display_mode_1080x2340_60hs
					&a55x_ana6710_panel_display_mode_1080x2340_30ns
				>;

				/* fhd */
				a55x_ana6710_panel_display_mode_1080x2340_120hs:
				a55x_ana6710_panel_display_mode_1080x2340_120hs {
					id = PANEL_DISPLAY_MODE_1080x2340_120HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <120>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <120>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <16 0 0>;	/* panel vbp:12, vfp:4, but for ap vblank set vbp:12+4, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <1>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <30>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <2107>;
				};

				a55x_ana6710_panel_display_mode_1080x2340_60phs:
				a55x_ana6710_panel_display_mode_1080x2340_60phs {
					id = PANEL_DISPLAY_MODE_1080x2340_60HS_120HS_TE_SW_SKIP_1;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <60>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_PASSIVE_HS>;
					panel_refresh_rate = <120>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <1>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <16 0 0>;	/* panel vbp:12, vfp:4, but for ap vblank set vbp:12+4, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <1>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <30>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <2107>;
				};

				a55x_ana6710_panel_display_mode_1080x2340_60hs:
				a55x_ana6710_panel_display_mode_1080x2340_60hs {
					id = PANEL_DISPLAY_MODE_1080x2340_60HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <60>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <60>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <2432 0 0>;	/* panel vbp:12, vfp:2420, but for ap vblank set vbp:12+2420, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <1>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <30>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <7991>;
				};

				a55x_ana6710_panel_display_mode_1080x2340_30ns:
				a55x_ana6710_panel_display_mode_1080x2340_30ns {
					id = PANEL_DISPLAY_MODE_1080x2340_30NS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <30>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_NS>;
					panel_refresh_rate = <30>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_NS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <16 0 0>;	/* panel vbp:12, vfp:4, but for ap vblank set vbp:12+4, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <1>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <30>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <19503>;
					doze_mode;
					panel_lp_mode;
				};
			};
		};
	};
};


/ {
	fragment@panel_drv {
		target-path = "/";
		__overlay__ {
			panel_drv_0: panel_drv_0 {
				status = "okay";
				compatible = "samsung,panel-drv";
				panel,id = <0>;

				ana6710_a55x_power_ctrl:
				ana6710_a55x_power_ctrl {
					actions {
						ana6710_a55x_vci_on: vci-on {
							type = <PCTRL_REGULATOR_ENABLE>;
							reg = <&ddi_vci>;
						};
						ana6710_a55x_vdd3_on: vdd3-on {
							type = <PCTRL_REGULATOR_ENABLE>;
							reg = <&ddi_vdd3>;
						};
						ana6710_a55x_vci_off: vci-off {
							type = <PCTRL_REGULATOR_DISABLE>;
							reg = <&ddi_vci>;
						};
						ana6710_a55x_vdd3_off: vdd3-off {
							type = <PCTRL_REGULATOR_DISABLE>;
							reg = <&ddi_vdd3>;
						};
						ana6710_a55x_delay_1ms: delay-1ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <1>;
						};
						ana6710_a55x_delay_2ms: delay-2ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <2>;
						};
						ana6710_a55x_delay_11ms: delay-11ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <11>;
						};
						ana6710_a55x_delay_21ms: delay-21ms {
							type = <PCTRL_DELAY_USLEEP>;
							value = <21000>;
						};
						ana6710_a55x_reset_high: reset-high {
							type = <PCTRL_GPIO_ENABLE>;
							gpio = <&disp_reset>;
						};
						ana6710_a55x_reset_low: reset-low {
							type = <PCTRL_GPIO_DISABLE>;
							gpio = <&disp_reset>;
						};
						ana6710_a55x_vci_set_3p0: vci-set-3p0 {
							type = <PCTRL_REGULATOR_SET_VOLTAGE>;
							reg = <&ddi_vci>;
							value = <3000000>;
						};
					};
					sequences {
						panel_boot_on = <
								&ana6710_a55x_vci_set_3p0
								&ana6710_a55x_vci_on
								&ana6710_a55x_vdd3_on
						>;
						panel_power_on = <
								&ana6710_a55x_vdd3_on
								&ana6710_a55x_delay_1ms
								&ana6710_a55x_vci_set_3p0
								&ana6710_a55x_vci_on
								&ana6710_a55x_delay_21ms
								&ana6710_a55x_reset_high
								&ana6710_a55x_delay_11ms
						>;
						panel_power_off = <
								&ana6710_a55x_delay_2ms
								&ana6710_a55x_reset_low
								&ana6710_a55x_delay_1ms
								&ana6710_a55x_vci_off
								&ana6710_a55x_delay_11ms
								&ana6710_a55x_vdd3_off
						>;
					};
				};

				ana6710_55x_ap:ana6710_55x_ap {
					/* S.LSI */
					SLSI,size = <71 153>;       /* 70.524 x 152.802 */
					SLSI,hdr_formats = <(HDR_FORMAT_HDR10 | HDR_FORMAT_HLG | HDR_FORMAT_HDR10P)>;
					SLSI,hdr_max_luma = <4500000>;	/* 450 */
					SLSI,hdr_max_avg_luma = <1200000>;	/* 120 */
					SLSI,hdr_min_luma = <5>;		/* 0.0005 */
					/* ignore ANAPASS err-report */
					SLSI,ignore-rx-trail;
				};

				panels {
					/* find ana6710_a55x panel header */
					ana6710_a55x: ana6710_a55x {
						ap-vendor-setting = <&ana6710_55x_ap>;
						display-mode = <&a55x_ana6710_panel_display_modes>;
						power-ctrl = <&ana6710_a55x_power_ctrl>;
						dqe-suffix = "ana6710_a55x";
						sdp-adaptive-mipi = <&ana6710_a55x_sdp_adaptive_mipi_info>;
						id-mask = <
							PANEL_ID(0x000040) PANEL_MASK(0x0000F0)
							PANEL_ID(0x000000) PANEL_MASK(0x000000)
						>;
					};
				};
			};
		};
	};
};


/* #include "../samsung_debug_6_1.dtsi" */           /* From samsung_debug_6_1.py */
/* SAMSUNG s5e9945 board device tree source
 *
 * Copyright (c) 2021 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

/ {
	fragment@sec_debug {
		target-path = "/";
		__overlay__ {
			sec_debug {
				compatible = "samsung,sec_debug";
				status = "okay";
				memory-region = <&sec_debug_next>;
				bdev_path = "/dev/block/by-name/debug";
			};
		};
	};

	fragment@sec_debug_built {
		target-path = "/";
		__overlay__ {
			sec_debug_built {
				compatible = "samsung,sec_debug_built";
				status = "okay";
				memory-region = <&sec_debug_next>;
			};
		};
	};

	fragment@sec_debug_test {
		target-path = "/";
		__overlay__ {
			sec_debug_test_device {
				compatible = "samsung,sec_debug_test";
				status = "okay";
			};
		};
	};

	fragment@sec_debug_reset_reason {
		target-path = "/";
		__overlay__ {
			sec_debug_reset_reason: sec_debug_reset_reason {
				compatible = "samsung,sec_debug_reset_reason";
				power_off_src = "OVP", "OI", "LDO_OI", "RSV3",
						"RSV4", "RSV5", "RSV6", "RSV7",
						"SUB_OFF", "TSD", "TIMEOUT", "LDO_SYS_OK",
						"PWRHOLD", "WTSR_TOUT", "SMPL_TOUT", "UVLOB";
				power_on_src =  "PWRON", "JIGONB", "ACOKB", "MRST",
						"ALARM", "INST_ACOK", "SMPL", "WTSR";
				rst_stat = "RSVD0", "RSVD1", "RSVD2", "RSVD3",
					"RSVD4", "RSVD5", "RSVD6", "RSVD7",
					"RSVD8", "RSVD9", "RSVD10", "RSVD11",
					"RSVD12", "RSVD13", "RSVD14", "RSVD15",
					"PINRESET", "DNC_CPU_WDTRESET", "SSP_CPU_WDTRESET", "OIS_CPU_WDTRESET",
					"APM_CPU0_WDTRESET", "APM_CPU1_WDTRESET", "VTS_CPU_WDTRESET", "CHUB_WDTRESET",
					"CLUSTER0_WDTRESET", "CLUSTER2_WDTRESET", "AUD_CPU0_WDTRESET", "SSS_CPU_WDTRESET",
					"DBGC_CPU_WDTRESET", "WRESET", "SWRESET", "PORESET";
			};
		};
	};
};

&reserved_memory {
	sec_debug_next: sec_debug_next {
		reg = <0x0 0x91200000 0x00200000>;
		no-map;
	};
};

/* #include "../common/input_booster_s5e9945.dtsi" *//* From input_booster_s5e9945.py */
/*
 * Samsung Mobile Input-Booster device tree
 *
 * Copyright (c) 2018 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

&smd {
	input_booster {
		status = "okay";
		compatible = "input_booster";
		resValcount = "3";
		max_resource_count = "7";
		max_cluster_count = "3";
		#address-cells = <1>;
		#size-cells = <0>;

		/* Each Cpu Cluster Start Cpu */
		cpu_cluster_policy = "7,4,0";
		/* < CLUSTER2, CLUSTER1, CLUSTER0, MIF, INT, HMP, UCC> */
		ib_release_values = "0,0,0,0,0,0,0";
		/* Select Allowed Resource Index Group */
		allowed_resources = "0,3,5";
		
		/* Mode Number 
		 *	DEFAULT_MODE = 0;
		 *	DISABLE_MODE = 1;
		 *	SIP_MODE = 2;
		 *	GAME_MODE = 3;
		*/

		booster@1 {
			booster,label = "Disable_Mode";
			booster,mode = "1";
			booster_key@1 {
				input_booster,label = "Touch_Disable";
				input_booster,type = <2>;	/* BOOSTER_DEVICE_TOUCH */
				/* Time table */
				input_booster,head_time = <0>;
				input_booster,tail_time = <0>;
				input_booster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "CPU";
						resource,id = "0";
						resource,value = <0 0>;
					};
				};
			};
		};

		booster@2 {
			booster,label = "Sip_Mode";
			booster,mode = "2";
			booster_key@1 {
				input_booster,label = "sip_touch";
				input_booster,type = <2>;	/* BOOSTER_DEVICE_TOUCH */
				/* Time table */
				input_booster,head_time = <200>;
				input_booster,tail_time = <0>;
				input_booster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "CPU";
						resource,id = "0";
						resource,value = <1152000 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 0>;
					};
				};
			};
		};

		booster@3 {
			booster,label = "Game_Mode";
			booster,mode = "3";
			booster_key@1 {
				input_booster,label = "GAME_MT";
				input_booster,type = <3>;	/* BOOSTER_DEVICE_MULTITOUCH */
				/* Time table */
				input_booster,head_time = <0>;
				input_booster,tail_time = <0>;
				input_booster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "CPU";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <0 0>;
					};
				};
			};
			booster_key@2 {
				input_booster,label = "GAME_TOUCH";
				input_booster,type = <2>;	/* BOOSTER_DEVICE_TOUCH */

				/* Time table */
				input_booster,head_time = <0>;
				input_booster,tail_time = <0>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "CPU";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <0 0>;
					};
				};
			};
		};

		booster@4 {
			booster,label = "input_booster";
			booster,mode = "0";

			booster_key@1 {
				input_booster,label = "key";
				input_booster,type = <0>;	/* BOOSTER_DEVICE_KEY */

				/* Time table */
				input_booster,head_time = <500>;
				input_booster,tail_time = <0>;

				/* resource Table Sequentially identified with index
				 * CLUSTER2's ID & Index : 0 (or UFC)
				 * CLUSTER1's ID & Index : 1
				 * CLUSTER0's ID & Index : 2
				 * MIF's ID & Index      : 3
				 * INT's ID & Index      : 4
				 * HMP's ID & Index      : 5
				 * UCC's ID & Index      : 6
				 */

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 0>;
					};
				};
			};

			booster_key@2 {
				input_booster,label = "touchkey";
				input_booster,type = <1>;	/* BOOSTER_DEVICE_TOUCHKEY */

				/* Time table */
				input_booster,head_time = <200>;
				input_booster,tail_time = <0>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 0>;
					};
				};
			};

			booster_key@3 {
				input_booster,label = "touch";
				input_booster,type = <2>;	/* BOOSTER_DEVICE_TOUCH */

				/* Time table */
				input_booster,head_time = <130>;
				input_booster,tail_time = <500>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 1>;
					};
				};
			};

			booster_key@4 {
				input_booster,label = "multitouch";
				input_booster,type = <3>;	/* BOOSTER_DEVICE_MULTITOUCH */

				/* Time table */
				input_booster,head_time = <1000>;
				input_booster,tail_time = <500>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 1>;
					};
				};
			};

			booster_key@5 {
				input_booster,label = "keyboard";
				input_booster,type = <4>;	/* BOOSTER_DEVICE_KEYBOARD */

				/* Time table */
				input_booster,head_time = <130>;
				input_booster,tail_time = <0>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 0>;
					};
				};
			};

			booster_key@6 {
				input_booster,label = "MOUSE";
				input_booster,type = <5>;	/* BOOSTER_DEVICE_MOUSE */

				/* Time table */
				input_booster,head_time = <130>;
				input_booster,tail_time = <500>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 1>;
					};
				};
			};

			booster_key@7 {
				input_booster,label = "mouse_wheel";
				input_booster,type = <6>;	/* BOOSTER_DEVICE_MOUSE */

				/* Time table */
				input_booster,head_time = <130>;
				input_booster,tail_time = <0>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 0>;
					};
				};
			};

			booster_key@8 {
				input_booster,label = "pen_hover";
				input_booster,type = <7>;	/* BOOSTER_DEVICE_MOUSE */

				/* Time table */
				input_booster,head_time = <130>;
				input_booster,tail_time = <500>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 1>;
					};
				};
			};

			booster_key@9 {
				input_booster,label = "pen";
				input_booster,type = <8>;	/* BOOSTER_DEVICE_MOUSE */

				/* Time table */
				input_booster,head_time = <200>;
				input_booster,tail_time = <600>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <0 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@6 {
						resource,label = "level";
						resource,id = "5";
						resource,value = <1 1>;
					};
				};
			};
			/* If you need to add new key type, add it this position */
		};
	};
};

/* #include "../samsung_6_1.dtsi" */                 /* From samsung_6_1.py */
/* SAMSUNG board device tree source
 *
 * Copyright (c) 2021 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

/ {
	fragment@model {
		target-path = "/";
		__overlay__ {
			sec-reboot {
				compatible = "samsung,sec-reboot";
				samsung,syscon-phandle = <&pmu_system_controller>;
				shutdown-offset = <0x3F90>; /* PS_HOLD_CONTROL */
				shutdown-trigger = <0x100>; /* PS_HOLD_DATA_BIT */
				magic-inform = <0x00B8>; /* INFORM2 */
				panic-inform = <0x00BC>; /* INFORM3 */
			};
		};
	};
};

/* #include "../sec_pinctrl_wrapper_v3.dtsi" */      /* From sec_pinctrl_wrapper_v3.py */
#define ___count_args(_0, _1, _2, _3, _4, _5, _6, _7, _8, x, ...) x

#define __count_args(...)					\
	___count_args(__VA_ARGS__, 7, 6, 5, 4, 3, 2, 1, 0)

#define PIN_AP_FUNC_INPUT		0x0
#define PIN_AP_FUNC_OUTPUT		0x1
#define PIN_AP_FUNC_OUTPUT_HIGH		0x1
#define PIN_AP_FUNC_OUTPUT_LOW		0x1
#define PIN_AP_FUNC_INPUT_WAKEUP	0xf

#define PIN_AP_VAL_FUNC_INPUT		0x0
#define PIN_AP_VAL_FUNC_OUTPUT		0x0
#define PIN_AP_VAL_FUNC_OUTPUT_HIGH	0x1
#define PIN_AP_VAL_FUNC_OUTPUT_LOW	0x0
#define PIN_AP_VAL_FUNC_INPUT_WAKEUP	0x0


#define PIN_PM_FUNC_INPUT		pmic-gpio,input-enable
#define PIN_PM_FUNC_OUTPUT		pmic-gpio,output-enable
#define PIN_PM_FUNC_OUTPUT_HIGH		pmic-gpio,output-high
#define PIN_PM_FUNC_OUTPUT_LOW		pmic-gpio,output-low

#define PIN_AP_FUNC_PWM			0x2
#define PIN_AP_FUNC_I2C			0x2

#define PIN_PULL_NONE	0
#define PIN_PULL_DOWN	1
#define PIN_PULL_UP	3

#define PIN_PM_PULL_NONE	pmic-gpio,pull-disable
#define PIN_PM_PULL_DOWN	pmic-gpio,pull-down
#define PIN_PM_PULL_UP		pmic-gpio,pull-up

/*
 * Typical GPIO
 * 0x0 | 2 mA
 * 0x1 | 4 mA
 * 0x2 | 8 mA
 * 0x3 | 12 mA
 */

#define PIN_AP_DRV_LV1	0x0
#define PIN_AP_DRV_LV2	0x1
#define PIN_AP_DRV_LV3	0x1
#define PIN_AP_DRV_LV4	0x2
#define PIN_AP_DRV_LV5	0x2
#define PIN_AP_DRV_LV6	0x3
#define PIN_AP_DRV_LV7	0x3
#define PIN_AP_DRV_LV8	0x3

#define PIN_PM_DRV_LV1	0x0
#define PIN_PM_DRV_LV2	0x1
#define PIN_PM_DRV_LV3	0x2
#define PIN_PM_DRV_LV4	0x3
#define PIN_PM_DRV_LV5	0x4
#define PIN_PM_DRV_LV6	0x5
#define PIN_PM_DRV_LV7	0x5
#define PIN_PM_DRV_LV8	0x5

#define PIN_EXPAND(pin) #pin

#define GPIO_KEY_WAKEUP		gpio-key,wakeup
#define GPIO_KEY_NONE		gpio-key,none
#define GPIO_KEY_CAN_DISABLE	linux,can-disable

#define SEC_GPIO(src, handle, type, num)	SEC_ ##src## _GPIO(type, num)
#define SEC_AP_GPIO(type, num)	PIN_EXPAND(type##-num)
#define SEC_PM_GPIO(type, num)	PIN_EXPAND(type ##num)

#define SEC_GPIO_REF(src, handle, type, num)	SEC_ ##src## _GPIO_REF(handle, num)
#define SEC_AP_GPIO_REF(handle, num)	&handle num
#define SEC_PM_GPIO_REF(handle, num)	&handle num
#define SEC_GPIO_PHANDLE_ACTIVE(src, type, num)	SEC_GPIO_PHANDLE(type, num, active)
#define SEC_GPIO_PHANDLE_SLEEP(src, type, num)	SEC_GPIO_PHANDLE(type, num, sleep)
#define SEC_GPIO_PHANDLE(type, num, mode)	type##_##num##_##mode

#define SEC_GPIO_NUM(src, handle, type, num)	num

#define SEC_GPIO_TYPE(src, handle, type, num)	&handle

#define GPIO_CONFIG(src, handle, type, num, func)			GPIO_ ##src## _CONFIG(type, num, func)
#define GPIO_CONFIG_PUD(src, handle, type, num, func, pull)		GPIO_ ##src## _CONFIG_PUD(type, num, func, pull)
#define GPIO_CONFIG_PUD_DRV(src, handle, type, num, func, pull, drv)	GPIO_ ##src## _CONFIG_PUD_DRV(type, num, func, pull, drv)

#define GPIO_AP_CONFIG(_type, _num, _func)		\
	samsung,pins = SEC_AP_GPIO(_type, _num);	\
	samsung,pin-function = <PIN_AP_ ##_func>;	\
	samsung,pin-val = <PIN_AP_VAL_ ##_func>

#define GPIO_AP_CONFIG_PUD(_type, _num, _func, _pull)	\
	samsung,pins = SEC_AP_GPIO(_type, _num);	\
	samsung,pin-function = <PIN_AP_ ##_func>;	\
	samsung,pin-val = <PIN_AP_VAL_ ##_func>;		\
	samsung,pin-pud = <PIN_ ##_pull>

#define GPIO_AP_CONFIG_PUD_DRV(_type, _num, _func, _pull, _drv)	\
	samsung,pins = SEC_AP_GPIO(_type, _num);		\
	samsung,pin-function = <PIN_AP_ ##_func>;		\
	samsung,pin-val = <PIN_AP_VAL_ ##_func>;			\
	samsung,pin-pud = <PIN_ ##_pull>;			\
	samsung,pin-drv = <PIN_AP_ ##_drv>

#define GPIO_PM_CONFIG(_type, _num, _func)		\
	pins = SEC_PM_GPIO(_type, _num);			\
	PIN_PM_ ##_func				

#define GPIO_PM_CONFIG_PUD(_type, _num, _func, _pull)	\
	pins = SEC_PM_GPIO(_type, _num);		\
	PIN_PM_ ##_func;				\
	PIN_PM_ ##_pull

#define GPIO_PM_CONFIG_PUD_DRV(_type, _num, _func, _pull, _drv)	\
	pins = SEC_PM_GPIO(_type, _num);			\
	PIN_PM_ ##_func;					\
	PIN_PM_ ##_pull;					\
	pmic-gpio,drive-strength = <PIN_PM_ ##_drv>

#define SEC_ADC(type, num) <&type num>
#define SEC_ADC_OPT(type, num) ,<&type num>

#define GPIO_KEY_CONFIG(_code, _gpio, _wakeup, _interval)	\
	label = PIN_EXPAND(_code);							\
	linux,code = <_code>;						\
	gpios = <_gpio 0xf>;						\
	GPIO_KEY_ ##_wakeup;						\
	debounce-interval = <_interval>

#define SEC_INTERFACE_REF(type, num)	&type num


/* #include "../vibrator_vib_info.dtsi" */           /* From vibrator_vib_info.py */

&smd {
	vib_info: vibrator_info {
		status = "okay";
		compatible = "samsung,vib-info";
		functions = "INTENSITY", "HAPTIC_ENGINE", "INDEX_HAPTIC_PATTERN", "COMMON_INPUTFF_INTERFACE", "PRIMITIVE_EFFECT_COMPOSE", "HYBRID_PATTERN_COMMON_INPUTFF";
#if 1
		samsung,intensities = <0 3000 4000 6000 8000 10000>;
#else
		samsung,intensities = <>;
#endif

#if 0
		samsung,haptic_intensities = <>;
#else
		samsung,haptic_intensities = <0 3000 5000 6700 8400 10000>;
#endif
	};
};

/* #include "../nc.dtsi" */                          /* From nc.py */
#define LEGO_IS_USE_NC
#define LEGO_IS_USE(x, ...) !defined(LEGO_IS_USE_##x)

/* #include "../sensorhub_s5e9945.dtsi" */           /* From sensorhub_s5e9945.py */
&contexthub_0 {
	multi-os = "disabled";
};

/ {
	fragment@model {
		target-path = "/";
		__overlay__ {
			shub {
				compatible = "shub";
			};
		};
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/sensorhub/lsi/s5e9945/dts/sensorhub_s5e9945.r12s.dtsi */
/ {
	fragment@model {
		target-path = "/";
		__overlay__ {
			shub {
				acc-lsm6dsvtr-position = <5>;
				mag-ak09918c-position = <2>;
				mag-ak09918c-array = /bits/ 8 <23 85 37 71 159 50 0 67 205 53 175 158 122 213 253 92 254 108 51 108 189 254 77 101 13 45 193>;
				mag-ak09918c-cover-array = /bits/ 8 <23 85 37 71 159 50 0 67 205 53 175 158 122 213 253 92 254 108 51 108 189 254 77 101 13 45 193>;
				brightness-resolution = <10>;
				brightness-array-len = <11>;
				brightness-array = /bits/ 32 <19 48 54 58 63 67 70 73 75 77 100>;
				light-position = /bits/ 32 <27 79 4 25 3 1>;
				fcd-axis = <1>;
				fcd-threshold = <(700)>;
				pressure-sw-offset = <8>;
			};
		};
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/sensorhub/lsi/s5e9945/dts/sensorhub_s5e9945.r12s.04.dtsi */
/ {
	fragment@model {
		target-path = "/";
		__overlay__ {
			shub {
				mag-ak09918c-array = /bits/ 8 <161 85 40 204 134 202 0 64 205 53 81 55 159 102 254 122 254 104 182 77 188 255 65 90 14 117 176>;
				mag-ak09918c-cover-array = /bits/ 8 <161 85 40 204 134 202 0 64 205 53 81 55 159 102 254 122 254 104 182 77 188 255 65 90 14 117 176>;
			};
		};
	};
};
/* #include "../kq_mesh.dtsi" */                     /* From kq_mesh.py */
&smd {
	kq-mesh {
		compatible = "samsung,kq-mesh";
		status = "okay";

		features {
			user_nad {
				user_nad,copy_area_len = <2>;
				/* address-cells=<2>, .align PAGE_SIZE */
				user_nad,copy_area_address_arr = <0x8 0x80100000 0x8 0x92800000>;
				/* size-cells=<1>, .align PAGE_SIZE */
				user_nad,copy_area_size_arr = <0x0D700000 0x0CE00000>;
			};
		};
	};
};

/* #include "../sec_vibrator_inputff.dtsi" */        /* From sec_vibrator_inputff.py */

&smd {
	sec_vib_inputff {
		status = "okay";
		compatible = "sec_vib_inputff";

		haptic,normal_ratio = <100>;
		haptic,overdrive_ratio = <100>;
#if 0
		haptic,fold_string = "";

		haptic,tent_open_ratio = <100>;
		haptic,tent_close_ratio = <100>;

		/* Fold open & close ratio required for vertial motor,
		 * may not be required for Harizontal motor
		 */
		haptic,fold_open_ratio = <100>;
		haptic,fold_close_ratio = <100>;
#endif
		haptic,high_temp_ref = <48>;
		haptic,high_temp_ratio = <70>;
		haptic,f0_cal_way = "AUTO";
	};
};


/* #include "../usb_vendor_notify.dtsi" */           /* From usb_vendor_notify.py */
&smd {
	usb_vendor_notify: usb_vendor_notify {
		compatible = "samsung,usb_vendor_notify";
	};

	usb_vendor_receiver: usb_vendor_receiver {
		compatible = "samsung,usb_vendor_receiver";
		notify = <&usb_vendor_notify>;
	};
};

/* #include "../display_ana6710_r12s.dtsi" */        /* From display_ana6710_r12s.py */
/*
 * Samsung Exynos SoC series Panel driver
 *
 * Copyright (c) 2020 Samsung Electronics Co., Ltd
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <dt-bindings/display/panel-display.h>
#include <dt-bindings/display/exynos-display.h>
#include "../display_ana6710_r12s_adaptive_mipi.dtsi"

&dsim_modes {
	1080x2340@120hs {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <3449>;
	};
	1080x2340@60phs {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <3449>;
	};
	1080x2340@60hs {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <10442>;
	};
	1080x2340@30ns {
		exynos,pmsk = <
			0x5 0x59 0x0 0xAC00
			0x0 0x0 0x0 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1362>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <24489>;
	};
};

&drmdsim_0 {
	hs_pll_timing = <&dsim_hs_pll_timing>;
};

/ {
	fragment@panel_display_mode {
		target-path = "/";
		__overlay__ {
			r12s_ana6710_panel_display_modes:
			r12s_ana6710_panel_display_modes {
				native-mode = <&r12s_ana6710_panel_display_mode_1080x2340_120hs>;
				exposed-mode = <
					&r12s_ana6710_panel_display_mode_1080x2340_120hs
					&r12s_ana6710_panel_display_mode_1080x2340_60phs
					&r12s_ana6710_panel_display_mode_1080x2340_60hs
					&r12s_ana6710_panel_display_mode_1080x2340_30ns
				>;

				/* fhd */
				r12s_ana6710_panel_display_mode_1080x2340_120hs:
				r12s_ana6710_panel_display_mode_1080x2340_120hs {
					id = PANEL_DISPLAY_MODE_1080x2340_120HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <120>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <120>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <16 0 0>;	/* panel vbp:12, vfp:4, but for ap vblank set vbp:12+4, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <1>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <30>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <3449>;
				};

				r12s_ana6710_panel_display_mode_1080x2340_60phs:
				r12s_ana6710_panel_display_mode_1080x2340_60phs {
					id = PANEL_DISPLAY_MODE_1080x2340_60HS_120HS_TE_SW_SKIP_1;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <60>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_PASSIVE_HS>;
					panel_refresh_rate = <120>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <1>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <16 0 0>;	/* panel vbp:12, vfp:4, but for ap vblank set vbp:12+4, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <1>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <30>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <3449>;
				};

				r12s_ana6710_panel_display_mode_1080x2340_60hs:
				r12s_ana6710_panel_display_mode_1080x2340_60hs {
					id = PANEL_DISPLAY_MODE_1080x2340_60HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <60>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <60>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <2432 0 0>;	/* panel vbp:12, vfp:2420, but for ap vblank set vbp:12+2420, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <1>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <30>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <10442>;
				};

				r12s_ana6710_panel_display_mode_1080x2340_30ns:
				r12s_ana6710_panel_display_mode_1080x2340_30ns {
					id = PANEL_DISPLAY_MODE_1080x2340_30NS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <30>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_NS>;
					panel_refresh_rate = <30>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_NS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <16 0 0>;	/* panel vbp:12, vfp:4, but for ap vblank set vbp:12+4, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <1>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <30>;	/* height of dsc slice */
					/* dsi parameters */
					cmd_lp_ref = <24489>;
					doze_mode;
					panel_lp_mode;
				};
			};
		};
	};
};


/ {
	fragment@panel_drv {
		target-path = "/";
		__overlay__ {
			panel_drv_0: panel_drv_0 {
				status = "okay";
				compatible = "samsung,panel-drv";
				panel,id = <0>;

				ana6710_r12s_power_ctrl:
				ana6710_r12s_power_ctrl {
					actions {
						ana6710_r12s_vci_on: vci-on {
							type = <PCTRL_REGULATOR_ENABLE>;
							reg = <&ddi_vci>;
						};
						ana6710_r12s_vdd3_on: vdd3-on {
							type = <PCTRL_REGULATOR_ENABLE>;
							reg = <&ddi_vdd3>;
						};
						ana6710_r12s_vci_off: vci-off {
							type = <PCTRL_REGULATOR_DISABLE>;
							reg = <&ddi_vci>;
						};
						ana6710_r12s_vdd3_off: vdd3-off {
							type = <PCTRL_REGULATOR_DISABLE>;
							reg = <&ddi_vdd3>;
						};
						ana6710_r12s_delay_1ms: delay-1ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <1>;
						};
						ana6710_r12s_delay_2ms: delay-2ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <2>;
						};
						ana6710_r12s_delay_11ms: delay-11ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <11>;
						};
						ana6710_r12s_delay_21ms: delay-21ms {
							type = <PCTRL_DELAY_USLEEP>;
							value = <21000>;
						};
						ana6710_r12s_reset_high: reset-high {
							type = <PCTRL_GPIO_ENABLE>;
							gpio = <&disp_reset>;
						};
						ana6710_r12s_reset_low: reset-low {
							type = <PCTRL_GPIO_DISABLE>;
							gpio = <&disp_reset>;
						};
						ana6710_r12s_vci_set_3p0: vci-set-3p0 {
							type = <PCTRL_REGULATOR_SET_VOLTAGE>;
							reg = <&ddi_vci>;
							value = <3000000>;
						};
					};
					sequences {
						panel_boot_on = <
								&ana6710_r12s_vci_set_3p0
								&ana6710_r12s_vci_on
								&ana6710_r12s_vdd3_on
						>;
						panel_power_on = <
								&ana6710_r12s_vdd3_on
								&ana6710_r12s_delay_1ms
								&ana6710_r12s_vci_set_3p0
								&ana6710_r12s_vci_on
								&ana6710_r12s_delay_21ms
								&ana6710_r12s_reset_high
								&ana6710_r12s_delay_11ms
						>;
						panel_power_off = <
								&ana6710_r12s_delay_2ms
								&ana6710_r12s_reset_low
								&ana6710_r12s_delay_1ms
								&ana6710_r12s_vci_off
								&ana6710_r12s_delay_11ms
								&ana6710_r12s_vdd3_off
						>;
					};
				};

				ana6710_r12s_ap:ana6710_r12s_ap {
					/* S.LSI */
					SLSI,size = <71 154>;       /* 71.280 x 154.44 */
					SLSI,hdr_formats = <(HDR_FORMAT_HDR10 | HDR_FORMAT_HLG | HDR_FORMAT_HDR10P)>;
					SLSI,hdr_max_luma = <4500000>;	/* 450 */
					SLSI,hdr_max_avg_luma = <1200000>;	/* 120 */
					SLSI,hdr_min_luma = <5>;		/* 0.0005 */
					/* ignore ANAPASS err-report */
					SLSI,ignore-rx-trail;
				};

				panels {
					/* find ana6710_r12s panel header */
					ana6710_r12s: ana6710_r12s {
						ap-vendor-setting = <&ana6710_r12s_ap>;
						display-mode = <&r12s_ana6710_panel_display_modes>;
						power-ctrl = <&ana6710_r12s_power_ctrl>;
						dqe-suffix = "ana6710_r12s";
						sdp-adaptive-mipi = <&ana6710_r12s_sdp_adaptive_mipi_info>;
						id-mask = <
							PANEL_ID(0x800000) PANEL_MASK(0xE000F0)
							PANEL_ID(0x000000) PANEL_MASK(0x000000)
						>;
					};
				};
			};
		};
	};
};


/* #include "../max77775_charger.dtsi" */            /* From max77775_charger.py */
&smd {
	max77775_charger: max77775-charger {
			charger,fac_vsys = <3800>;
	};

	battery {
		battery,fgsrc_switch_name = "max77775-charger";
		battery,otg_name = "max77775-otg";
	};
};


/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/battery/suwon/charger/max77775/max77775_charger.r12s.dtsi */
&max77775_charger {
	charger,enable_sysovlo_irq;
	charger,fac_vsys = <4400>;

	charger,fsw = <2>; /* 1.5MHz */
	charger,enable_noise_wa;
	charger,bar_type; /* only for bar type */
};

/* #include "../abc_spec_manager_type1.dtsi" */      /* From abc_spec_manager_type1.py */
&smd {
	sec_abc {
		compatible = "samsung,sec_abc";
		status = "okay";
		abc_spec_type1 {
			module_list = "gpu", "gpu_qc", "gpu_qc", "camera", "camera", "vib", "tsp", "tsp_sub", "mm", "camera", "camera", "camera", "camera", "camera", "camera", "camera", "camera", "camera", "gpu";
			name_list = "gpu_fault", "gpu_fault", "gpu_page_fault", "mipi_overflow", "i2c_fail", "int_gnd_short", "tsp_int_fault", "tsp_int_fault", "venus_hung", "mipi_error_rw1", "mipi_error_rs1", "mipi_error_rt1", "mipi_error_fw1", "mipi_error_rt2", "mipi_error_uw1", "mipi_error_rm1", "mipi_error_rb1", "mipi_error_fs1", "gpu_job_timeout";
#ifndef CONFIG_SEC_FACTORY
			threshold_cnt = <20>, <2>, <20>, <1>, <1>, <25>, <2>, <2>, <10>, <1>, <1>, <1>, <1>, <1>, <1>, <1>, <1>, <1>, <7>;
			threshold_time = <1200>, <1200>, <1200>, <0>, <0>, <5>, <5>, <5>, <3>, <0>, <0>, <0>, <0>, <0>, <0>, <0>, <0>, <0>, <600>;
#else
			threshold_cnt = <20>, <2>, <20>, <4>, <4>, <25>, <2>, <2>, <10>, <4>, <4>, <4>, <4>, <4>, <4>, <4>, <4>, <4>, <1>;
			threshold_time = <1200>, <1200>, <1200>, <120>, <120>, <5>, <5>, <5>, <3>, <120>, <120>, <120>, <120>, <120>, <120>, <120>, <120>, <120>, <600>;
#endif
		};
	};
};

/* #include "../display_panel_manager.dtsi" */       /* From display_panel_manager.py */
/*
 * Samsung Exynos SoC series Panel driver
 *
 * Copyright (c) 2020 Samsung Electronics Co., Ltd
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <dt-bindings/display/panel-display.h>

/ {
	fragment@panel_drv {
		target-path = "/";
		__overlay__ {
			panel_drv_0: panel_drv_0 {
				status = "okay";
				compatible = "samsung,panel-drv";
				panel,id = <0>;

				panel-lut {
#if 1
					panel_0 = <&ana6710_r12s>;
#endif
#if 1
					panel_1 = <&ana6710_a55x>;
#endif
#if 0
					panel_2 = <&${panel_name_2}>;
#endif
#if 0
					panel_3 = <&${panel_name_3}>;
#endif
#if 0
					panel_4 = <&${panel_name_4}>;
#endif
#if 0
					panel_5 = <&${panel_name_5}>;
#endif
#if 0
					panel_6 = <&${panel_name_6}>;
#endif
#if 0
					panel_7 = <&${panel_name_7}>;
#endif
#if 0
					panel_8 = <&${panel_name_8}>;
#endif
#if 0
					panel_9 = <&${panel_name_9}>;
#endif
				};
			};
		};
	};
};


/* #include "../ap_slsi_s5e9945.dtsi" */             /* From ap_slsi_s5e9945.py */
#include <dt-bindings/clock/s5e9945.h>
#include "../../exynos/board/erd/erd9945-pmic.dtsi"

/* #include "../usb_notifier.dtsi" */                /* From usb_notifier.py */

&smd {
	usb_notifier {
		compatible = "samsung,usb-notifier";
		udc = <&udc>;
		status = "okay";
#if 0
		support_reverse_bypass_en;
#endif
	};
};


/* #include "../abc_common.dtsi" */                  /* From abc_common.py */
&smd {
	abc_hub {
		compatible = "samsung,abc_hub";
		status = "okay";
		bootc {
			bootc,time_spec_user = <100000>; /* user binary user build */
			bootc,time_spec_eng = <150000>; /* user binary eng build */
			bootc,time_spec_fac = <100000>; /* factory binary */
		};
	};
};

/* #include "../dio8018.dtsi" */                     /* From dio8018.py */
&pinctrl_0 {
	dio8018_0_irq: dio8018_0_irq {
		GPIO_CONFIG_PUD(AP,gpa1,gpa1,1, FUNC_INPUT, PULL_NONE);
	};
};

&pinctrl_0 {
	dio8018_0_hw_reset: dio8018_0_hw_reset {
		GPIO_CONFIG_PUD(AP,gpa2,gpa2,6, FUNC_OUTPUT_LOW, PULL_NONE);
	};
};

&hsi2c_36 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";

	dio8018_0_pmic: dio8018_pmic@35{
		compatible = "dioo,dio8018pmic";
		reg = <0x35>;
		dio8018,wakeup;
		pinctrl-names = "default";
		pinctrl-0 = <&dio8018_0_irq>;
		dio8018,dio8018_int = <SEC_GPIO_REF(AP,gpa1,gpa1,1) 0>;
		dio8018,dio8018_int_level = <0>;
		dio8018,dio8018_int_outmode = <1>;
		dio8018,dio8018_reset = <SEC_GPIO_REF(AP,gpa2,gpa2,6) 0>;
		dio8018,need_sw_reset;

		regulators {
			reg_dio8018_0_ldo1: dio8018-ldo1 {
				regulator-name = "VDD_WIDECAM_0P92";
				regulator-min-microvolt = <920000>;
				regulator-max-microvolt = <920000>;
				
				regulator-min-microamp = <1300000>;regulator-max-microamp = <1800000>;
			};

			reg_dio8018_0_ldo2: dio8018-ldo2 {
				regulator-name = "VDD_WIDECAM_PHY_0P92";
				regulator-min-microvolt = <920000>;
				regulator-max-microvolt = <920000>;
				
				regulator-min-microamp = <1300000>;regulator-max-microamp = <1800000>;
			};
	
			reg_dio8018_0_ldo3: dio8018-ldo3 {
				regulator-name = "VDD_WIDECAM_A2P2";
				regulator-min-microvolt = <2204000>;
				regulator-max-microvolt = <2204000>;
				
				regulator-min-microamp = <450000>;regulator-max-microamp = <650000>;
			};

			reg_dio8018_0_ldo4: dio8018-ldo4 {
				regulator-name = "VDD_UWCAM_A2P8";
				regulator-min-microvolt = <2804000>;
				regulator-max-microvolt = <2804000>;
				
				regulator-min-microamp = <450000>;regulator-max-microamp = <650000>;
			};

			reg_dio8018_0_ldo5: dio8018-ldo5 {
				regulator-name = "VDD_VTCAM_A2P95";
				regulator-min-microvolt = <1500000>;
				regulator-max-microvolt = <3412000>;
				
				regulator-min-microamp = <650000>;regulator-max-microamp = <950000>;

			};

			reg_dio8018_0_ldo6: dio8018-ldo6 {
				regulator-name = "VDD_TELECAM_A2P8";
				regulator-min-microvolt = <2804000>;
				regulator-max-microvolt = <2804000>;
				
				regulator-min-microamp = <450000>;regulator-max-microamp = <650000>;
			};

			reg_dio8018_0_ldo7: dio8018-ldo7 {
				regulator-name = "VDD_TELECAM_OIS_2P8";
				regulator-min-microvolt = <2804000>;
				regulator-max-microvolt = <2804000>;
				
				regulator-min-microamp = <650000>;regulator-max-microamp = <950000>;
			};
		};
	};
};

/* #include "../pmic_S2MPS27.dtsi" */                /* From pmic_S2MPS27.py */
#if 1800000 && 1800000
&l1_reg {
	regulator-name = "vdd_ldo1";
	regulator-min-microvolt = <1800000>;
	regulator-max-microvolt = <1800000>;
	 
	
};
#endif

#if 0 && 0
&l2_reg {
	regulator-name = "vdd_ldo2";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l3_reg {
	regulator-name = "vdd_ldo3";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l4_reg {
	regulator-name = "vdd_ldo4";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l5_reg {
	regulator-name = "vdd_ldo5";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l6_reg {
	regulator-name = "vdd_ldo6";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l7_reg {
	regulator-name = "vdd_ldo7";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l8_reg {
	regulator-name = "vdd_ldo8";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 3000000 && 3000000
&l9_reg {
	regulator-name = "vdd_ldo9";
	regulator-min-microvolt = <3000000>;
	regulator-max-microvolt = <3000000>;
	 
	/delete-property/ regulator-always-on;/delete-property/ regulator-boot-on;
};
#endif

#if 3000000 && 3000000
&l10_reg {
	regulator-name = "vdd_ldo10";
	regulator-min-microvolt = <3000000>;
	regulator-max-microvolt = <3000000>;
	 
	regulator-boot-on;/delete-property/ regulator-always-on;
};
#endif

#if 0 && 0
&l11_reg {
	regulator-name = "vdd_ldo11";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 1800000 && 1800000
&l12_reg {
	regulator-name = "vdd_ldo12";
	regulator-min-microvolt = <1800000>;
	regulator-max-microvolt = <1800000>;
	 
	/delete-property/ regulator-always-on;/delete-property/ regulator-boot-on;
};
#endif

#if 1800000 && 1800000
&l13_reg {
	regulator-name = "VDD_WIDECAM_IO_1P8";
	regulator-min-microvolt = <1800000>;
	regulator-max-microvolt = <1800000>;
	 
	
};
#endif

#if 1800000 && 1800000
&l14_reg {
	regulator-name = "vdd_ldo14";
	regulator-min-microvolt = <1800000>;
	regulator-max-microvolt = <1800000>;
	 regulator-ramp-delay = <12000>;regulator-initial-mode = <1>;
	regulator-always-on;
};
#endif

#if 0 && 0
&l15_reg {
	regulator-name = "vdd_ldo15";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 1800000 && 1800000
&l16_reg {
	regulator-name = "vdd_ldo16";
	regulator-min-microvolt = <1800000>;
	regulator-max-microvolt = <1800000>;
	 
	/delete-property/ regulator-always-on;/delete-property/ regulator-boot-on;
};
#endif

#if 1800000 && 1800000
&l17_reg {
	regulator-name = "vdd_ldo17";
	regulator-min-microvolt = <1800000>;
	regulator-max-microvolt = <1800000>;
	 
	regulator-boot-on;/delete-property/ regulator-always-on;
};
#endif

#if 1800000 && 1800000
&l18_reg {
	regulator-name = "vdd_ldo18";
	regulator-min-microvolt = <1800000>;
	regulator-max-microvolt = <1800000>;
	 
	/delete-property/ regulator-always-on;/delete-property/ regulator-boot-on;
};
#endif

/* #include "../hall_ic.dtsi" */                     /* From hall_ic.py */
/*
 * Hall ic device tree source
 *
 * Copyright (c) 2017 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

&smd {
	hall_ic: hall_ic {
		status = "okay";
		compatible = "hall_ic";
		pinctrl-names = "default";
		pinctrl-0 = <
#if 1
		&hall_irq
#endif
#if 0
		&certify_hall_irq
#endif
#if 0
		&hall_wacom_irq
#endif
#if 0
		&folder_hall_irq
#endif
		>;
#if 1
		hall_ic,debounce-interval = <50>;
#endif
#if 1
		hall: hall {
			name = "hall";
			event = <0x15>;
			gpios = <SEC_GPIO_REF(AP,gpa1,gpa1,3) 1>;
		};
#endif
#if 0
		certify_hall: certify_hall {
			name = "certify_hall";
			event = <0x1b>;
			gpios = <SEC_GPIO_REF(${certify_hall_gpio}) 1>;
		};
#endif
#if 0
		hall_wacom: hall_wacom {
			name = "hall_wacom";
			event = <0x1e>;
			gpios = <SEC_GPIO_REF(${wacom_hall_gpio}) 1>;
		};
#endif
#if 0
		flip: flip {
			name = "flip";
			event = <0x00>;
			gpios = <SEC_GPIO_REF(${folder_hall_gpio}) 1>;
		};
#endif
	};

#if 0
	hall_logical {
		status = "okay";
		compatible = "hall_logical";
	};
#endif
};

#if 1
&pinctrl_0 {
	hall_irq: hall_irq {
		GPIO_CONFIG_PUD_DRV(AP,gpa1,gpa1,3, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
#if 0
		power-source = <1>;
#endif
	};
};
#endif

#if 0
&${certify_hall_parent} {
	certify_hall_irq: certify_hall_irq {
		GPIO_CONFIG_PUD_DRV(${certify_hall_gpio}, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
#if 0
		power-source = <1>;
#endif
	};
};
#endif

#if 0
&${wacom_hall_parent} {
	hall_wacom_irq: hall_wacom_irq {
		GPIO_CONFIG_PUD_DRV(${wacom_hall_gpio}, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
#if 0
		power-source = <1>;
#endif
	};
};
#endif

#if 0
&${folder_hall_parent} {
	folder_hall_irq: folder_hall_irq {
		GPIO_CONFIG_PUD_DRV(${folder_hall_gpio}, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
	};
};
#endif

/* #include "../vibrator_aw8624x.dtsi" */            /* From vibrator_aw8624x.py */
#define VIB_CONNECTED_AP_slsi

&pinctrl_0 {
	motor_int_default: motor-int {
		GPIO_CONFIG_PUD(AP,gpa3,gpa3,7, FUNC_INPUT_WAKEUP, PULL_UP);
	};
};

&pinctrl_7 {
	motor_rst_default: motor-rst {
		GPIO_CONFIG_PUD_DRV(AP,gpp2,gpp2,2, FUNC_OUTPUT, PULL_NONE, DRV_LV1);
		samsung,pin-con-pdn = <3>;
		samsung,pin-pud-pdn = <0>;
	};
};

&hsi2c_4 {
	status = "ok";
	i2c-scl-hz = <400000>;
	aw8624x: aw8624x_haptic@58 {
		reg = <0x58>;
		samsung,max_level_gain = <0x7C>;	/* max level gain */
#if 0
		samsung,f0-tracking;
		samsung,f0-tracking-offset = <0>;
#endif
	};
};

#include "../aw8624x.dtsi"

/* #include "../tusb2e11.dtsi" */                    /* From tusb2e11.py */
/*
 * Copyright (c) 2019 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#if 0
&${repeater_parent} {
	eusb_ctrl: eusb_ctrl_sel {
		GPIO_CONFIG_PUD_DRV(${repeater_gpio}, FUNC_OUTPUT_LOW, PULL_DOWN, DRV_LV1);
	};
};
#endif

&hsi2c_34 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	tusb2e11-repeater@3E {
		compatible = "tusb2e11-repeater";
		reg = <0x3E>;
		status = "okay";
#if 0
		pinctrl-name = "default";
		pinctrl-0 = <&eusb_ctrl>;
		eusb,gpio_eusb_ctrl = <SEC_GPIO_REF(${repeater_gpio}) 1>;
#endif
		repeater_tune_param {
			repeater_tune_cnt = /bits/ 8 <0x5>;
			/* 0xffffffff means using default value */
			repeater_tune1 {
				tune_name = "usb2_tx_adjust_port1";
				tune_value = /bits/ 8 <0x70 0x36>;
			};

			repeater_tune2 {
				tune_name = "usb2_hs_rx_pre_emphasus_p1";
				tune_value = /bits/ 8 <0x71 0x3e>;
			};

			repeater_tune3 {
				tune_name = "usb2_disconnect_squelch_port1";
				tune_value = /bits/ 8 <0x73 0x46>;
			};

			repeater_tune4 {
				tune_name = "eusb_rx_adjust_port1";
				tune_value = /bits/ 8 <0x79 0x70>;
			};

			repeater_tune5 {
				tune_name = "E_SOP_EOP";
				tune_value = /bits/ 8 <0x76 0x27>;
			};
		};
	};
};


/* #include "../pmic_S2MPS28.dtsi" */                /* From pmic_S2MPS28.py */
#if 1
#if 0 && 0
&s1_l1_reg {
	-name = "vdd_ldo1s1";
	-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s1_l2_reg {
	regulator-name = "vdd_ldo2s1";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s1_l3_reg {
	regulator-name = "vdd_ldo3s1";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s1_l4_reg {
	regulator-name = "vdd_ldo4s1";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s1_l5_reg {
	regulator-name = "vdd_ldo5s1";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif
#endif /* s2mps28_1_interface */

#if 1
#if 0 && 0
&s2_l1_reg {
	regulator-name = "vdd_ldo1s2";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s2_l2_reg {
	regulator-name = "vdd_ldo2s2";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s2_l3_reg {
	regulator-name = "vdd_ldo3s2";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s2_l4_reg {
	regulator-name = "vdd_ldo4s2";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s2_l5_reg {
	regulator-name = "vdd_ldo5s2";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif
#endif /* s2mps28_2_interface */

#if 1
#if 0 && 0
&s3_l1_reg {
	regulator-name = "vdd_ldo1s3";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s3_l2_reg {
	regulator-name = "vdd_ldo2s3";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s3_l3_reg {
	regulator-name = "vdd_ldo3s3";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s3_l4_reg {
	regulator-name = "vdd_ldo4s3";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 1243750 && 1243750
&s3_l5_reg {
	regulator-name = "VDD_TELECAM_1P245";
	regulator-min-microvolt = <1243750>;
	regulator-max-microvolt = <1243750>;
	 
	
};
#endif
#endif /* s2mps28_3_interface */

#if 1
#if 0 && 0
&s4_l1_reg {
	regulator-name = "vdd_ldo1s4";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s4_l2_reg {
	regulator-name = "vdd_ldo2s4";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 1050000 && 1050000
&s4_l3_reg {
	regulator-name = "VDD_VTCAM_1P05";
	regulator-min-microvolt = <1050000>;
	regulator-max-microvolt = <1050000>;
	 
	
};
#endif

#if 0 && 0
&s4_l4_reg {
	regulator-name = "vdd_ldo4s4";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s4_l5_reg {
	regulator-name = "vdd_ldo5s4";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif
#endif /* s2mps28_4_interface */

#if 1
#if 0 && 0
&s5_l1_reg {
	regulator-name = "vdd_ldo1s5";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s5_l2_reg {
	regulator-name = "vdd_ldo2s5";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s5_l3_reg {
	regulator-name = "vdd_ldo3s5";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s5_l4_reg {
	regulator-name = "vdd_ldo4s5";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s5_l5_reg {
	regulator-name = "vdd_ldo5s5";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif
#endif /* s2mps28_5_interface */

/* #include "../pmic_S2MPM07.dtsi" */                /* From pmic_S2MPM07.py */
&acpm_mfd_bus6 {
	status = "okay";
	#address-cells = <1>;
	#size-cells = <0>;

	s2mpm07_mfd: s2mpm07mfd@3f {
		compatible = "samsung,s2mpm07mfd";
		acpm-ipc-channel = <2>;
		s2mpm07,wakeup = "enabled";
		reg = <0x7f>;

		/* s2mpm07-gpio */
		s2mpm07_gpio: s2mpm07-gpio {
			gpio-controller;
			#gpio-cells = <2>;
			samsung,npins = <8>;
			status = "okay";
		};

		regulators {
			r_b1_reg: BUCK1 {
				regulator-name = "buck1r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <6000>;regulator-initial-mode = <3>;
				
			};

			r_b_sr1_reg: BUCK_SR1 {
				regulator-name = "buck_sr1r";
				regulator-min-microvolt = <600000>;
				regulator-max-microvolt = <1350000>;
				regulator-ramp-delay = <6000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};
/*
			r_l1_reg: LDO1 {
				regulator-name = "vdd_ldo1r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l2_reg: LDO2 {
				regulator-name = "vdd_ldo2r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l3_reg: LDO3 {
				regulator-name = "vdd_ldo3r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l4_reg: LDO4 {
				regulator-name = "vdd_ldo4r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l5_reg: LDO5 {
				regulator-name = "vdd_ldo5r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;

			};

			r_l6_reg: LDO6 {
				regulator-name = "vdd_ldo6r";
				regulator-min-microvolt = <1600000>;
				regulator-max-microvolt = <1900000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l7_reg: LDO7 {
				regulator-name = "vdd_ldo7r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l8_reg: LDO8 {
				regulator-name = "vdd_ldo8r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l9_reg: LDO9 {
				regulator-name = "vdd_ldo9r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;regulator-initial-mode = <3>;
				
			};

			r_l10_reg: LDO10 {
				regulator-name = "vdd_ldo10r";
				regulator-min-microvolt = <1600000>;
				regulator-max-microvolt = <1900000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};
*/
			r_l11_reg: LDO11 {
				regulator-name = "vdd_ldo11r";
				regulator-min-microvolt = <3100000>;
				regulator-max-microvolt = <3100000>;
				regulator-ramp-delay = <12000>;regulator-initial-mode = <3>;
				
			};
/*
			r_l12_reg: LDO12 {
				regulator-name = "vdd_ldo12r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l13_reg: LDO13 {
				regulator-name = "vdd_ldo13r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l14_reg: LDO14 {
				regulator-name = "${LDO14_name}";
				regulator-min-microvolt = <${LDO14_Vmin}>;
				regulator-max-microvolt = <${LDO14_Vmax}>;
				${LDO14_opt_properties}
				${LDO14_basic_properties}
			};

			r_l15_reg: LDO15 {
				regulator-name = "vdd_ldo15r";
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1300000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l16_reg: LDO16 {
				regulator-name = "vdd_ldo16r";
				regulator-min-microvolt = <1600000>;
				regulator-max-microvolt = <1900000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l17_reg: LDO17 {
				regulator-name = "${LDO17_name}";
				regulator-min-microvolt = <${LDO17_Vmin}>;
				regulator-max-microvolt = <${LDO17_Vmax}>;
				${LDO17_opt_properties}
				${LDO17_basic_properties}
			};
*/
			r_l18_reg: LDO18 {
				regulator-name = "VDD_TELECAM_AF_2P8";
				regulator-min-microvolt = <2800000>;
				regulator-max-microvolt = <2800000>;
				regulator-ramp-delay = <12000>;regulator-initial-mode = <3>;
				
			};

			r_l19_reg: LDO19 {
				regulator-name = "r_l19";
				regulator-min-microvolt = <2800000>;
				regulator-max-microvolt = <2800000>;
				regulator-ramp-delay = <12000>;regulator-initial-mode = <3>;
				
			};
/*
			r_l20_reg: LDO20 {
				regulator-name = "vdd_ldo20r";
				regulator-min-microvolt = <1800000>;
				regulator-max-microvolt = <3375000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};

			r_l21_reg: LDO21 {
				regulator-name = "vdd_ldo21r";
				regulator-min-microvolt = <1800000>;
				regulator-max-microvolt = <3375000>;
				regulator-ramp-delay = <12000>;
				regulator-initial-mode = <3>;
				regulator-always-on;
			};
*/
		}; /* end of regulators */
	}; /* end of s2mpm07mfd@00 */
}; /* end of acpm_mfd_bus@11a20000 */

/* #include "../pmic_S2MPA05.dtsi" */                /* From pmic_S2MPA05.py */
/* USE_AS_AP_SUB_PMIC */
#if !(1)
#if 3300000 && 3300000
&s_l1_reg {
	regulator-name = "VDD_WIDECAM_AF_3P3";
	regulator-min-microvolt = <3300000>;
	regulator-max-microvolt = <3300000>;
	  regulator-ramp-delay = <12000>; regulator-initial-mode = <3>;
	
};
#endif

#if 2800000 && 2800000
&s_l2_reg {
	regulator-name = "VDD_TELECAM_AF_2P8_PM";
	regulator-min-microvolt = <2800000>;
	regulator-max-microvolt = <2800000>;
	 
	
};
#endif

#if 3300000 && 3300000
&s_l3_reg {
	regulator-name = "VDD_WIDECAM_OIS_3P3";
	regulator-min-microvolt = <3300000>;
	regulator-max-microvolt = <3300000>;
	 
	
};
#endif

#if 1050000 && 1050000
&s_l4_reg {
	regulator-name = "VDD_UWCAM_1P05";
	regulator-min-microvolt = <1050000>;
	regulator-max-microvolt = <1050000>;
	 
	
};
#endif
#else
/* USE_AS_CAMERA_PMIC */
#if 3300000 && 3300000
&e_l1_reg {
	regulator-name = "VDD_WIDECAM_AF_3P3";
	regulator-min-microvolt = <3300000>;
	regulator-max-microvolt = <3300000>;
	  regulator-ramp-delay = <12000>; regulator-initial-mode = <3>;
	
};
#endif

#if 2800000 && 2800000
&e_l2_reg {
	regulator-name = "VDD_TELECAM_AF_2P8_PM";
	regulator-min-microvolt = <2800000>;
	regulator-max-microvolt = <2800000>;
	 
	
};
#endif

#if 3300000 && 3300000
&e_l3_reg {
	regulator-name = "VDD_WIDECAM_OIS_3P3";
	regulator-min-microvolt = <3300000>;
	regulator-max-microvolt = <3300000>;
	 
	
};
#endif

#if 1050000 && 1050000
&e_l4_reg {
	regulator-name = "VDD_UWCAM_1P05";
	regulator-min-microvolt = <1050000>;
	regulator-max-microvolt = <1050000>;
	 
	
};
#endif
#endif

/* #include "../nu2111a_charger.dtsi" */             /* From nu2111a_charger.py */
&hsi2c_16 {
	status = "okay";

	nu2111a_charger: nu2111a@6e {
		compatible = "nuvolta,nu2111a";
		reg = <0x6e>;
#if 0
		nu2111a,sub_i2c-bus = <&${sub_direct_charger_i2c}>;
#endif
		nu2111a,vbat-reg = <4450000>;
		nu2111a,input-current-limit = <3000000>; /* 3.0A */
		nu2111a,charging-current = <6000000>; /* 6.0A */
		nu2111a,topoff-current = <400000>; /* 400mA */
		nu2111a,chg-mode = <1>; /* 2:1 direct charging mode */
		nu2111a,cv-polling = <2000>; /* 2000ms */
		nu2111a,step1-cv=<4200000>; /* 4200mV */
		nu2111a,wd-tmr=<0x04>; /* 5s */
		/* WDT enabled */
		//nu2111a,wd-dis;
	};
};

#if 0
&${sub_direct_charger_i2c} {
	status = "okay";
};
#endif

/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/battery/suwon/charger/nu2111a/nu2111a_charger.r12s.dtsi */
&nu2111a_charger {
	nu2111a,sw-freq = <0x7>; /* 1000kHz */
};

/* #include "../max77775.dtsi" */                    /* From max77775.py */
/*
 * Copyright (c) 2019 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

&pinctrl_0 {
	if_pmic_irq: if_pmic_irq {
		GPIO_CONFIG_PUD_DRV(AP,gpa0,gpa0,0, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
#if 0
		power-source = <0>;
#endif
	};
};

&hsi2c_16 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	max77775: max77775@66 {
		status = "okay";
		compatible = "maxim,max77775";
		reg = <0x66>;
		pinctrl-names = "default";
		pinctrl-0 = <&if_pmic_irq>;
		max77775,irq-gpio = <SEC_GPIO_REF(AP,gpa0,gpa0,0) 1>;
		max77775,rev = <0x04>;
#if 1
		max77775,fw_product_id = <0x05>;
#else
		max77775,fw_product_id = <0x01>;
#endif
#if 1
		max77775,extra_fw_enable = <0>;
#else
		max77775,extra_fw_enable = <0>;
#endif
		max77775,support-audio;
#if 2
		max77775,bc1p2_retry_count = <2>;
#endif
		/* same samples as MD15 */ 
		max77775,snkcap_data = [04 2c 91 01 36 c8 d0 02 00 c8 90 41 8b 2e 21 dc c0];
	};
};

&max77775 {
	max77775_pdic {
		status = "okay";
		compatible = "maxim,max77775_pdic";
		support_pd_role_swap;
	};
};

/* #include "../stk6d2x.dtsi" */                     /* From stk6d2x.py */
#if !defined(CONFIG_SEC_FACTORY_INTERPOSER)
&hsi2c_32 {
	status = "okay";
	clock-frequency = <1000000>;

	stk@47 {
		status = "okay";
		compatible = "stk,stk6d2x";

#if 0
		reg = <0x47 0x0 0x10>;
		als_rear,i3c = <1>;
#else
		reg = <0x47>;
#endif

#if 1
		als_rear,use_ext_clk;
		clocks = <&clock DOUT_DIV_CLKCMU_CIS_CLK6>, <&clock GATE_DFTMUX_CMU_QCH_CIS_CLK6>;
		clock-names = "div_clk", "mux_clk";

		pinctrl-names = "default", "sleep", "active";
		pinctrl-0 = <&sensor_mclk6_out>;
		pinctrl-1 = <&sensor_mclk6_out>;
		pinctrl-2 = <&sensor_mclk6_fn>;
#endif
		stk,als_scale = <1000>;
		//stk,als_is_dri;
#if 1
		vdd_1p8-supply	= < &l1_reg >;
#endif
#if 0
		vbus_1p8-supply	= < &${flicker_ldo_vbus} >;
#endif
	};
};
#endif


/* #include "../sec_auth_ds28e30.dtsi" */            /* From sec_auth_ds28e30.py */
&smd {
	sec_auth_ds28e30: sec-auth-ds28e30 {
			status = "okay";
			compatible = "samsung,sec_auth_ds28e30";
#if 1
			sec_auth_ds28e30,swi_gpio = <
				SEC_GPIO_REF(AP,gpp3,gpp3,0) 0 /* SWI_GPIO */
#if 0
				SEC_GPIO_REF(${swi_gpio_2}) 0 /* SWI_GPIO_2 */
#endif
			>;
#endif
			};
};


/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/battery/suwon/battery_auth/ds28e30/r12s/sec_auth_ds28e30.dtsi */
#if 1
&pinctrl_7 {
		sec_auth_gpio_init: sec_auth_gpio_init {
			GPIO_CONFIG_PUD(AP,gpp3,gpp3,0, FUNC_OUTPUT_HIGH, PULL_NONE);
		};
		sec_auth_gpio_sleep: sec_auth_gpio_sleep {
			GPIO_CONFIG_PUD(AP,gpp3,gpp3,0, FUNC_OUTPUT_HIGH, PULL_NONE);
		};
	};
#endif

&smd {
	sec_auth_ds28e30: sec-auth-ds28e30 {
		status = "okay";
		compatible = "samsung,sec_auth_ds28e30";
#if 1
		/* SWI_GPIO */
		ds28e30,swi_gpio = <SEC_GPIO_REF(AP,gpp3,gpp3,0) 0 >;
		/* s5e9945.dts (ggp3[0])--> Change according to AP and GPIO */
		ds28e30,base_phys_addr = <0x11830000 0x1000>;
		/* Control register, Data register --> Change according to AP and GPIO */
		ds28e30,offset = <0xE0 0xE4>;
		/* Control bit is 0th , Data bit is 0th --> Change according to AP and GPIO */
		ds28e30,bit_pos = <0 0>;
		/* Set CPU mask */
		ds28e30,cpu_start = <4>;
		ds28e30,cpu_end = <6>;
		pinctrl-names = "init", "sleep";
		pinctrl-0 = <&sec_auth_gpio_init>;
		pinctrl-1 = <&sec_auth_gpio_sleep>;
#endif
#if 1
		ds28e30,sub6_det_gpio1 = <SEC_GPIO_REF(PM,s2mpm07_gpio,gpio_r,1) 0 >;
		ds28e30,sub6_det_gpio2 = <SEC_GPIO_REF(PM,s2mpm07_gpio,gpio_r,2) 0 >;
		ds28e30,sub6_det_gpio3 = <SEC_GPIO_REF(PM,s2mpm07_gpio,gpio_r,3) 0 >;
#endif
	};
};

/* #include "../sec_direct_charger.dtsi" */          /* From sec_direct_charger.py */

&smd {
	sec-direct-charger {
		status = "okay";
		compatible = "samsung,sec-direct-charger";

		charger,battery_name = "battery";
		charger,main_charger = "max77775-charger";
		charger,direct_charger = "nu2111a-charger";

	#if 0
		charger,direct_chargers =
				"nu2111a-charger",
				"${direct_charger_name2}";
	#endif

		charger,dchg_min_current = <2000>;

		charger,ta_alert_wa;
	};
};


/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/battery/suwon/common/sec_direct_charger/dts/r12s/sec_direct_charger.dtsi */
&smd {
	sec-direct-charger {
		charger,end_soc = <100>;
		charger,fpdo_dc_max_vbat = <4050>;
	};

	pass-through {
		start_delay = <5000>; /* msec */
		init_delay = <5000>; /* msec */
		min_cap = <200>; /* 0.1 % */
		fixed_sc_cap = <900>; /* 0.1 % */
		max_icl = <3000>; /* mA */
	};
};

/* #include "../max77775_fuelgauge.dtsi" */          /* From max77775_fuelgauge.py */
&smd {
	max77775_fuelgauge: max77775-fuelgauge {
			    /* for 4500mAh battery */
			    status = "okay";
			    fuelgauge,fuel_alert_soc = <1>;
			    fuelgauge,jig_gpio = <SEC_GPIO_REF(AP,gpa4,gpa4,1) 0>; /* IFC_SENSE_INT_AP */
			    fuelgauge,jig_low_active;
			    fuelgauge,capacity_max = <1000>;
			    fuelgauge,capacity_max_margin = <300>;
			    fuelgauge,capacity_min = <0>;
			    fuelgauge,capacity_calculation_type = <28>;
			    fuelgauge,repeated_fuelalert;
			    fuelgauge,using_temp_compensation;
			    fuelgauge,low_temp_limit = <100>;
			    fuelgauge,vempty_recover_time = <180>; /* 3 mins */
			    fuelgauge,using_hw_vempty;
			    fuelgauge,sw_v_empty_voltage = <3200>;
			    fuelgauge,sw_v_empty_voltage_cisd = <3100>;
			    fuelgauge,sw_v_empty_recover_voltage = <3480>;
			    fuelgauge,fg_resistor = <2>;
#if 1
			    fuelgauge,bat_id_gpio = <
#if 0
					SEC_GPIO_REF(${bat_id_gpio_2}) 0 /* BAT_ID_GPIO 1 */
#endif
					SEC_GPIO_REF(PM,s2mps28_2_gpio,gpio_s,3) 0 /* BAT_ID_GPIO 0 */
					>;
#endif
#if 0
			    fuelgauge,sub_bat_id_gpio = <
#if 0
					SEC_GPIO_REF(${sub_bat_id_gpio_2}) 0 /* SUB_BAT_ID_GPIO 1 */
#endif
					SEC_GPIO_REF(${sub_bat_id_gpio}) 0 /* SUB_BAT_ID_GPIO 0 */
					>;
#endif
		    };
};

/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/battery/suwon/fuelgauge/max77775/r12s/max77775_fuelgauge.dtsi */
&max77775_fuelgauge {
	fuelgauge,capacity_calculation_type = <0x5C>;
	fuelgauge,lost_soc_trig_soc = <1000>; /* 100.0% */
	fuelgauge,lost_soc_trig_d_soc = <20>; /* 2% */
	fuelgauge,lost_soc_trig_scale = <2>; /* 2x */
	fuelgauge,lost_soc_guarantee_soc = <30>; /* 3.0% */
	fuelgauge,lost_soc_min_vol = <3200>; /* 3200mV */
	fuelgauge,fg_resistor = <5>; /* 2 milliohm */


	battery_params {
		/*
		 * BAT_ID_1/BAT_ID_2
		 * 1: ATL, 0: SDI
		 */

		/* 0 : SDI battery data */
		battery0,v_empty = <0xA561>; /* Empty: 3400mV, Recover: 4000mV */
		battery0,v_empty_origin = <0x7D54>; /* Empty: 2500mV, Recover: 3360mV */
		battery0,capacity = <0x0708>;
					/* fullcapnom dPacc dQacc RCOMP0 TempCo */
		battery0,fg_reset_wa_data = <0x0708 0x3200 0x01C2 0x002F 0x171F>;
		battery0,low_temp_filtercfg = <0xCEA6>;
		battery0,normal_temp_filtercfg = <0XCEA3>;

		battery0,data_ver = <0x3>;

		battery0,selected_reg = <
			0x02 0x7F80	/* default */
			0x12 0x3C00	/* QResidual00 */
			0x1E 0x0247	/* ICHGTerm */
			0x21 0x6200	/* default */
			0x22 0x1E00	/* QResidual10 */
			0x2A 0x023C	/* RelaxCFG */
			0x2C 0xE3E1	/* TGAIN */
			0x2D 0x290E	/* TOFF */
			0x2E 0x0400	/* CGAIN */
			0x2F 0x0001	/* COFF */
			0x32 0x0F00	/* QResidual20 */
			0x33 0xFFFF	/* default */
			0x37 0x05E0	/* default */
			0x42 0x0D00	/* QResidual30 */
			0xB4 0x7F80	/* default */
			0xB8 0x0000	/* default */
			0xB9 0x006B	/* default */
			0xBA 0x090C	/* default */
			>;

		/* 1 : ATL battery data */
		battery1,v_empty = <0xA561>; /* Empty: 3400mV, Recover: 4000mV */
		battery1,v_empty_origin = <0x7D54>; /* Empty: 2500mV, Recover: 3360mV */
		battery1,capacity = <0x03b6>;
					/* fullcapnom dPacc dQacc RCOMP0 TempCo */
		battery1,fg_reset_wa_data = <0x03b6 0x3200 0x00ed 0x06d0 0x1802>;
		battery1,low_temp_filtercfg = <0xC616>;
		battery1,normal_temp_filtercfg = <0xC613>;

		battery1,data_ver = <0x5>;

		battery1,selected_reg = <
			0x02 0x7F80	/* default */
			0x12 0x3600	/* QResidual00 */
			0x1E 0x0240	/* ICHGTerm */
			0x21 0x6200	/* default */
			0x22 0x1b00	/* QResidual10 */
			0x2A 0x023E	/* RelaxCFG */
			0x2C 0xE3E1	/* TGAIN */
			0x2D 0x290E	/* TOFF */
			0x2E 0x0400	/* CGAIN */
			0x2F 0x0001	/* COFF */
			0x32 0x0d80	/* QResidual20 */
			0x33 0xFFFF	/* default */
			0x37 0x05E0	/* default */
			0x42 0x0a80	/* QResidual30 */
			0xB4 0x7F80	/* default */
			0xB8 0x0000	/* default */
			0xB9 0x006B	/* default */
			0xBA 0x090C	/* default */
			>;
	};
};

/* #include "../sensorhub_shub.dtsi" */              /* From sensorhub_shub.py */
#if 1
&l14_reg {
	regulator-name = "VDD_SENSOR_1P8";
};
#endif
#if 0
&${gpio_sensor_ldo_en_parent} {
	shub_sensor_ldo_en: shub-sensor-ldo-en {
		samsung,pins = SEC_GPIO(${gpio_sensor_ldo_en});
		samsung,pin-function = <1>;
		samsung,pin-pud = <0>;
		samsung,pin-con-pdn = <3>;
		samsung,pin-pud-pdn = <0>;
	};
};
#endif
#if 0
&${gpio_prox_ldo_en_parent} {
	shub_prox_ldo_en: shub-prox-ldo-en {
		samsung,pins = SEC_GPIO(${gpio_prox_ldo_en});
		samsung,pin-function = <1>;
		samsung,pin-pud = <0>;
		samsung,pin-con-pdn = <3>;
		samsung,pin-pud-pdn = <0>;
	};
};
#endif
#if 0
&${gpio_pogo_int_parent} {
	shub_pogo_int: shub-pogo-int {
		GPIO_CONFIG_PUD_DRV(${gpio_pogo_int}, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
	};
};
#endif
/ {
	fragment@model {
		target-path = "/";
		__overlay__ {
			shub {
				pinctrl-names = "default";
#if 0 || 0 || 0
				pinctrl-0 = <
#if 0
				&shub_sensor_ldo_en
#endif
#if 0
				&shub_prox_ldo_en
#endif
#if 0
				&shub_pogo_int
#endif
>;
#endif

#if 1
				sensor-vdd-regulator = "VDD_SENSOR_1P8";
#endif

#if 0
				mag-check-nfc = <SEC_GPIO_REF(${gpio_nfc_check}) 0>;
#endif

#if 0
				pogo-int = <SEC_GPIO_REF(${gpio_pogo_int}) 0>;
#endif

#if 0
				sensor-ldo-en = <SEC_GPIO_REF(${gpio_sensor_ldo_en}) 0>;
#endif
#if 0
				prox-ldo-en = <SEC_GPIO_REF(${gpio_prox_ldo_en}) 0>;
#endif
			};
		};
	};
};

/* #include "../display_common_oled_board.dtsi" */   /* From display_common_oled_board.py */
/*
 * Samsung Exynos SoC series Panel driver
 *
 * Copyright (c) 2020 Samsung Electronics Co., Ltd
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#if 1
#define ERR_FG_Disable
#endif

#if defined(ERR_FG_1)
#define ERR_FG_TRUE
#endif

&pinctrl_7 {
	disp_rst_default: disp-rst-default {
		samsung,pins = SEC_GPIO(AP,gpc7,gpc7,0);
		samsung,pin-function = <1>;	// OUT
		samsung,pin-pud = <0>;		// NP
		samsung,pin-con-pdn = <3>;	// PREV in sleep
		samsung,pin-pud-pdn = <0>;	// NP in sleep
	};
};

#if 1
&pinctrl_0 {
	disp_det_default: disp_det_default {
		GPIO_CONFIG_PUD(AP,gpa2,gpa2,2, FUNC_INPUT, PULL_DOWN);
	};
};
#endif

#if defined(ERR_FG_Rising_edge) || defined(ERR_FG_TRUE)
&${err_fg_parent} {
	err_fg_default: err_fg_default {
		GPIO_CONFIG_PUD(${err_fg_gpio}, FUNC_INPUT, PULL_DOWN);
	};
};
#endif

#if defined(ERR_FG_Falling_edge)
&${err_fg_parent} {
	err_fg_default: err_fg_default {
		GPIO_CONFIG_PUD(${err_fg_gpio}, FUNC_INPUT, PULL_UP);
	};
};
#endif

#if defined(ERR_FG_Falling_edge_pull_down)
&${err_fg_parent} {
	err_fg_default: err_fg_default {
		GPIO_CONFIG_PUD(${err_fg_gpio}, FUNC_INPUT, PULL_DOWN);
	};
};
#endif

#if 1
&pinctrl_0 {
	conn_det_default: conn_det_default {
		samsung,pins = SEC_GPIO(AP,gpa0,gpa0,7);
		samsung,pin-funciton = <0>;			// IN
		samsung,pin-pud = <0>;				// NP
		samsung,pin-con-pdn = <2>;			// IN
		samsung,pin-pud-pdn = <0>;			// NP in sleep
	};
};
#endif
#if 1
&pinctrl_6 {
	disp_te_default: disp_te_default {
		samsung,pins = SEC_GPIO(AP,gpg2,gpg2,0);
		samsung,pin-funciton = <0xf>;			// INT
		samsung,pin-pud = <1>;					// PD
		samsung,pin-con-pdn = <3>;				// PREV in sleep
		samsung,pin-pud-pdn = <0>;				// NP in sleep
	};
};
#endif
#if 1
&pinctrl_0 {
	pcd_default: pcd_default {
		GPIO_CONFIG_PUD(AP,gpa0,gpa0,1, FUNC_INPUT, PULL_DOWN);
	};
};
#endif

#if 0
&${avdd_en_parent} {
	avdd_en_default: avdd_en_default {
		samsung,pins = SEC_GPIO(${avdd_en_gpio});
		samsung,pin-function = <1>;	// OUT
		samsung,pin-pud = <0>;		// NP
		samsung,pin-con-pdn = <3>;	// PREV in sleep
		samsung,pin-pud-pdn = <0>;	// NP in sleep
	};
};
#endif

#if 0
&${poc_spi_parent} {
	poc_spi_sleep_state_np: poc_spi_sleep_state_np {
		samsung,pins = SEC_GPIO(${poc_spi_cs}), SEC_GPIO(${poc_spi_clk});
		samsung,pin-functions = <0>;	// GPIO
		samsung,pin-pud = <0>;		// NP
		samsung,pin-drv = <0>;
		samsung,pin-con-pdn = <2>;	// INPUT in sleep
		samsung,pin-pud-pdn = <0>;	// NP in sleep
	};
	poc_spi_sleep_state_pd: poc_spi_sleep_state_pd {
		samsung,pins = SEC_GPIO(${poc_spi_mosi}), SEC_GPIO(${poc_spi_miso});
		samsung,pin-functions = <0>;	// GPIO
		samsung,pin-pud = <1>;		// PD
		samsung,pin-drv = <0>;
		samsung,pin-con-pdn = <2>;	// INPUT in sleep
		samsung,pin-pud-pdn = <1>;	// PD in sleep
	};
};
#endif

#if 0
&${lcd_vendor_check_parent} {
	lcd_vendor_check_default: lcd_vendor_check_default {
		GPIO_CONFIG_PUD(${lcd_vendor_check_gpio}, FUNC_INPUT, PULL_NONE);
	};
};
#endif

#if 0
&${rst_ready_parent} {
	rst_ready_default: rst_ready_default {
		GPIO_CONFIG_PUD(${rst_ready_gpio}, FUNC_INPUT, PULL_DOWN);
	};
};
#endif

#if 1
&l10_reg {
	regulator-boot-on;
};
#endif

#if 1
&l17_reg {
	regulator-boot-on;
};
#endif

#if 0
&${ddr_vddr_reg} {
	regulator-boot-on;
};
#endif

/ {
	fragment@panel_drv {
		target-path = "/";
		__overlay__ {
			panel_drv_0: panel_drv_0 {
				pinctrl-names = "default";
				pinctrl-0 = <
							&disp_rst_default
#if defined(ERR_FG_Rising_edge) || defined(ERR_FG_Falling_edge) || defined(ERR_FG_TRUE) || defined(ERR_FG_Falling_edge_pull_down)
							&err_fg_default
#endif
#if 1
							&disp_det_default
#endif
#if 1
							&conn_det_default
#endif
#if 1
							&disp_te_default
#endif
#if 0
							&avdd_en_default
#endif
#if 0
							&poc_spi_sleep_state_np
							&poc_spi_sleep_state_pd
#endif
#if 0
							&lcd_vendor_check_default
#endif
#if 0
							&rst_ready_default
#endif
				>;

				gpios {
					disp_reset: disp-reset {
						gpios = <SEC_GPIO_REF(AP,gpc7,gpc7,0) 1>;	/* ACTIVE_LOW */
						dir = <0>;  /* OUT */
						irq-type = <0x0>;   /* NONE */
					};
#if 1
					disp_det: disp-det {
						gpios = <SEC_GPIO_REF(AP,gpa2,gpa2,2) 1>;  /* 0:OK, 1:NOK(active) */
						dir = <1>;  /* IN */
						irq-type = <0x2>;   /* FALLING EDGE */
						irq-pend {
							reg = <0x0 0x15850A34 0x0>;
							bit = <0x2>;
						};
					};
#endif
#if defined(ERR_FG_Rising_edge) || defined(ERR_FG_TRUE)
					err_fg: err-fg {
						gpios = <SEC_GPIO_REF(${err_fg_gpio}) 0>;		/* 0:NOK(active) 1:OK */
						dir = <1>;				/* IN */
						irq-type = <0x00002001>;	/* RISING EDGE | ONE_SHOT */
					};

#endif
#if defined(ERR_FG_Falling_edge) || defined(ERR_FG_Falling_edge_pull_down)
					err_fg: err-fg {
						gpios = <SEC_GPIO_REF(${err_fg_gpio}) 0>;		/* 0:NOK(active) 1:OK */
						dir = <1>;				/* IN */
						irq-type = <2>;	/* Falling EDGE | ONE_SHOT */
					};
#endif
#if 1
					conn_det: conn-det {
						gpios = <SEC_GPIO_REF(AP,gpa0,gpa0,7) 0>;
						dir = <1>;
						irq-type = <0x00002001>;	//RISING EDGE | ONE_SHOT
					};
#endif
#if 1
					pcd: pcd {
						gpios = <SEC_GPIO_REF(AP,gpa0,gpa0,1) 1>;		/* 0:NOK(active) 1:OK */
						dir = <1>;				/* IN */
						irq-type = <0x2>;   /* FALLING EDGE */
					};
#endif
#if 1
					disp_te: disp-te {
						gpios = <SEC_GPIO_REF(AP,gpg2,gpg2,0) 0>;		/* 0:NOK(active) 1:OK */
						dir = <1>;				/* IN */
						irq-type = <0x0>;   /* NONE */
					};
#endif
#if 0
					avdd_en: avdd-en {
						gpios = <SEC_GPIO_REF(${avdd_en_gpio}) 0>;
						dir = <0>;
						irq-type = <0x0>;   /* NONE */
					};
#endif
#if 0
					disp_reset_ready: disp_reset_ready {
						gpios = <SEC_GPIO_REF(${rst_ready_gpio}) 1>;		/* 0:NOK(active) 1:OK */
						dir = <1>;				/* IN */
						irq-type = <0x0>;   /* NONE */
					};
#endif

				};

				regulators {
#if 1
					ddi_vci: ddi-vci {
						regulator = <&l10_reg>;
						type = <REGULATOR_TYPE_PWR>;
						def-voltage = <3000000>;
					};
#endif
#if 1
					ddi_vdd3: ddi-vdd3 {
						regulator = <&l17_reg>;
						type = <REGULATOR_TYPE_PWR>;
						def-voltage = <1800000>;
					};
#endif
#if 0
					ddr_vddr: ddr-vddr {
						regulator = <&${ddr_vddr_reg}>;
						type = <REGULATOR_TYPE_PWR>;
						def-voltage = <1600000>;
					};
#endif
#if 0
					fd_elvdd: fd-elvdd {
						regulator = <&${fd_elvdd_reg}>;
						type = <REGULATOR_TYPE_PWR>;
					};
#endif
#if 0
					ssd_elvss: ssd-elvss {
						regulator = <&${ssd_elvss_reg}>;
						type = <REGULATOR_TYPE_SSD>;
					};
#endif
#if 0
					dpmic_elvdd_elvss: dpmic-elvdd-elvss {
						regulator = <&${dpmic_elvdd_elvss_reg}>;
						type = <REGULATOR_TYPE_PWR>;
					};
#endif
				};
			};
		};
	};
};

/* #include "../sec_auth_sle956681.dtsi" */          /* From sec_auth_sle956681.py */
&smd {
	sec_auth_sle956681: sec-auth-sle956681 {
			status = "okay";
			compatible = "samsung,sec_auth_sle956681";

			authon,power_mode = "indirect";
			//authon,power_mode = "direct";

#if 1
			authon,1tau_value = <60>;
			authon,3tau_value = <180>;
			authon,5tau_value = <300>;
			authon,response_timeout_value = <1530>;
			authon,swi_gpio = <
				SEC_GPIO_REF(AP,gpp3,gpp3,0) 0 /* SWI_GPIO */
#if 0
				SEC_GPIO_REF(${swi_gpio_2}) 0 /* SWI_GPIO_2 */
#endif
				>;
#endif
#if 0
			authon,1tau_value2 = <60>;
			authon,3tau_value2 = <180>;
			authon,5tau_value2 = <300>;
#endif
			};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/battery/suwon/battery_auth/sle956681/r12s/sec_auth_sle956681.dtsi */
&sec_auth_sle956681 {
	authon,1tau_value = <60>;
	authon,3tau_value = <180>;
	authon,5tau_value = <300>;
	authon,response_timeout_value = <4500>;
#if 1
	authon,sub6_det_gpio1 = <SEC_GPIO_REF(PM,s2mpm07_gpio,gpio_r,1) 0 >;
	authon,sub6_det_gpio2 = <SEC_GPIO_REF(PM,s2mpm07_gpio,gpio_r,2) 0 >;
	authon,sub6_det_gpio3 = <SEC_GPIO_REF(PM,s2mpm07_gpio,gpio_r,3) 0 >;
#endif
};

/* #include "../input_berlin.dtsi" */                /* From input_berlin.py */
&pinctrl_0 {
	berlin_attn_irq: berlin_attn_irq {
		GPIO_CONFIG_PUD(AP,gpa1,gpa1,2, FUNC_INPUT_WAKEUP, PULL_NONE);
	};

	berlin_attn_irq_suspend: berlin_attn_irq_suspend {
		GPIO_CONFIG_PUD(AP,gpa1,gpa1,2, FUNC_INPUT, PULL_NONE);
	};
};

&hsi2c_46 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";

	tsp_goodix: touchscreen@5d {
		status = "okay";
		compatible = "goodix,berlin";
		reg = <0x5d>;
		pinctrl-names = "on_state", "off_state";
		pinctrl-0 = <&berlin_attn_irq>;
		pinctrl-1 = <&berlin_attn_irq_suspend>;
#if LEGO_IS_USE(l18_reg, ...)
		tsp_io_ldo-supply = <&l18_reg>;
#endif
#if LEGO_IS_USE(l9_reg, ...)
		tsp_avdd_ldo-supply = <&l9_reg>;
#endif
		sec,irq_gpio = <SEC_GPIO_REF(AP,gpa1,gpa1,2) 0x2002>;
		support_dex_mode;
		sec,enable_sysinput_enabled;
		support_open_short_test;
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/input/sec_input_2024/touchscreen/goodix/berlin/dts/input-lsi-tsp-berlin.r12s.dtsi */
&tsp_goodix {
	status = "okay";
	sec,enable_sysinput_enabled;
	sec,max_coords = <1080 2340>; /* x y */
	sec,firmware_name = "tsp_goodix/gt9916k_r12s.bin";
	sec,bitmask_unload = <0xFFFF00 0x800000>; /* bitshift bitmask. this is for synaptics panel */

	enable_settings_aot;
	support_ear_detect_mode;
	support_fod;
	support_fod_lp_mode;
	support_gesture_uevent;
	support_vbus_notifier;

	goodix,enable_esd_check;
	goodix,ic_type = <3>; //GT9916K

	goodix,max_drv_num = <17>;
	goodix,max_sen_num = <37>;
	goodix,drv_map = <40 41 42 43 44 45 46 47
					48 49 50 51 52 53 54 55 56 57 58 59>;
	goodix,sen_map = <0 1 2 3 4 5 6 7 8 9 10 11 12
					13 14 15 16 17 18 19 20 21 22 23 24
					25 26 27 28 29 30 31 32 33 34 35 36
					37 38 39>;
	goodix,short_test_time_reg = <0x14D7A>;
	goodix,short_test_status_reg = <0x13400>;
	goodix,short_test_result_reg = <0x13408>;
	goodix,drv_drv_reg = <0x1344E>;
	goodix,sen_sen_reg = <0x137E6>;
	goodix,drv_sen_reg = <0x14556>;
	goodix,diff_code_reg = <0x14D00>;
	goodix,production_test_addr = <0x0000>; //unused

	goodix,switch_freq_cmd = <0xB1>;
	goodix,switch_cfg_cmd = <0x64>;
	goodix,snr_cmd = <0x65>;
	goodix,sensitive_cmd = <0x66>;

	goodix,isp_ram_reg = <0x23800>;
	goodix,flash_cmd_reg = <0x12400>;
	goodix,isp_buffer_reg = <0x12410>;
	goodix,config_data_reg = <0x3E000>;
	goodix,misctl_reg = <0xD804>;
	goodix,watch_dog_reg = <0xD040>;
	goodix,config_id_reg = <0x10076>;
	goodix,enable_misctl_val = <0x20700000>;
};

&hsi2c46_bus {
	samsung,pin-con-pdn = <3>;
	samsung,pin-pud-pdn = <3>;
};

/* #include "../fingerprint_gw9558x.dtsi" */         /* From fingerprint_gw9558x.py */
/*
 * SAMSUNG EXYNOS9630 board device tree source
 *
 * Copyright (c) 2018 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

&pinctrl_0 {
	gw9558x_rst: gw9558x-rst {
		samsung,pins = SEC_GPIO(AP,gpa0,gpa0,6);
		samsung,pin-function = <1>;
		samsung,pin-pud = <1>;
		samsung,pin-drv = <0>;
		samsung,pin-con-pdn = <3>;
		samsung,pin-pud-pdn = <1>;
	};
};

#if 0
&${fps_ldo_vdd_1p8_parent} {
	gw9558x_ldo: gw9558x-ldo {
		samsung,pins = SEC_GPIO(${fps_ldo_vdd_1p8});
		samsung,pin-function = <1>;
		samsung,pin-pud = <1>;
		samsung,pin-drv = <0>;
		samsung,pin-con-pdn = <3>;
		samsung,pin-pud-pdn = <1>;
	};
};
#endif

#if 1
&r_l11_reg {
	regulator-name = "VDD_BTP_3P3";
	regulator-min-microvolt = <3300000>;
	regulator-max-microvolt = <3300000>;
	regulator-ramp-delay = <12000>;
};
#endif

&pinctrl_7 {
	spi_fp_bus_inactive: spi-fp-bus-inactive {
		samsung,pins = SEC_GPIO(AP,gpp11,gpp11,3), SEC_GPIO(AP,gpp11,gpp11,0), SEC_GPIO(AP,gpp11,gpp11,1);
		samsung,pin-function = <1>;
		samsung,pin-pud = <0>;
		samsung,pin-drv = <1>;
		samsung,pin-val = <0>;
	};

	spi_fp_miso_inactive: spi-fp-miso-inactive {
		samsung,pins = SEC_GPIO(AP,gpp11,gpp11,2);
		samsung,pin-function = <0>;
		samsung,pin-pud = <1>;
		samsung,pin-drv = <1>;
	};

	spi_fp_clk: spi-fp-clk {
		samsung,pins = SEC_GPIO(AP,gpp11,gpp11,0);
		samsung,pin-function = <2>;
		samsung,pin-pud = <1>;
		samsung,pin-drv = <4>;
	};

	spi_fp_cs: spi-fp-cs {
		samsung,pins = SEC_GPIO(AP,gpp11,gpp11,3);
		samsung,pin-function = <2>;
		samsung,pin-pud = <3>;
		samsung,pin-drv = <4>;
	};

	spi_fp_miso: spi-fp-miso {
		samsung,pins = SEC_GPIO(AP,gpp11,gpp11,2);
		samsung,pin-function = <2>;
		samsung,pin-pud = <1>;
		samsung,pin-drv = <4>;
	};

	spi_fp_mosi: spi-fp-mosi {
		samsung,pins = SEC_GPIO(AP,gpp11,gpp11,1);
		samsung,pin-function = <2>;
		samsung,pin-pud = <1>;
		samsung,pin-drv = <4>;
	};
};

#if defined(CONFIG_SEC_FACTORY) || !1
&spi_11 {
	status = "okay";
	pinctrl-names = "";
	qos_trig_lvl = <51200>;
	int_qos_val = <100000>;
	dma-mode;
	swap-mode = <1>;
#else
&smd {
#endif
	gw9558 {
		compatible = "goodix,gw9558x";
		reg = <0>;
		spi-max-frequency = <25000000>;
#if !defined(CONFIG_SEC_FACTORY) && 1
		clocks = <&clock GATE_PERIC2_CMU_PERIC2_QCH>, <&clock DOUT_DIV_CLK_PERIC2_USI11>;
		clock-names = "gate_spi_clk", "ipclk_spi";
#endif
		pinctrl-names = "default", "pins_poweron", "pins_poweroff";
#if 0
		pinctrl-0 = <&gw9558x_ldo &gw9558x_rst>;
#else
		pinctrl-0 = <&gw9558x_rst>;
#endif
		pinctrl-1 = <&spi_fp_clk &spi_fp_cs &spi_fp_miso &spi_fp_mosi>;
		pinctrl-2 = <&spi_fp_bus_inactive &spi_fp_miso_inactive>;

		gpio-controller;
		#gpio-cells = <2>;

#if 0
		goodix,gpio_pwr = <SEC_GPIO_REF(${fps_ldo_vdd_1p8}) 0>;
#endif
#if 1
		goodix,btp-regulator = "VDD_BTP_3P3";
		VDD_BTP_3P3-supply = <&r_l11_reg>;
#endif
		goodix,gpio_reset = <SEC_GPIO_REF(AP,gpa0,gpa0,6) 0>;
		goodix,chip_id = "GW9588";
		goodix,position = "12.34,0.00,9.10,9.10,14.80,14.80,12.00,12.00,5.00";
		goodix,modelinfo = "S721";
		goodix,rb = "647,-1,-1,FFFFFF";

		controller-data {
			cs-gpio = <SEC_GPIO_REF(AP,gpp11,gpp11,3) 0>;
			samsung,spi-feedback-delay = <0>;
			samsung,spi-chip-select-mode = <0>;
		};
	};
};
/* #include "../nfc_lsi_nfc_2.dtsi" */               /* From nfc_lsi_nfc_2.py */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#if 1
#if 0
&${ese_check_parent} {
	ese_check_default: ese_check_default {
		GPIO_CONFIG_PUD_DRV(${ese_check}, FUNC_INPUT, PULL_NONE, DRV_LV3);
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
		samsung,pin-pud-pdn = <PIN_PULL_NONE>;
	};
};
#endif

&pinctrl_7 {
	ese_spi_bus_suspend: ese_spi_bus_suspend {
		samsung,pins = SEC_GPIO(AP,gpp1,gpp1,0), SEC_GPIO(AP,gpp1,gpp1,1), SEC_GPIO(AP,gpp1,gpp1,2);
		samsung,pin-function = <0>; /* INPUT */
		samsung,pin-pud = <PIN_PULL_DOWN>; /* DOWN */
		samsung,pin-drv = <PIN_AP_DRV_LV1>;
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
		samsung,pin-pud-pdn = <PIN_PULL_DOWN>;
	};

	ese_spi_cs_suspend: ese_spi_cs_suspend {
		samsung,pins = SEC_GPIO(AP,gpp1,gpp1,3);
		samsung,pin-function = <1>; /* OUTPUT */
		samsung,pin-pud = <PIN_PULL_NONE>; /* NONE */
		samsung,pin-drv = <PIN_AP_DRV_LV1>;
		samsung,pin-val = <1>;
		samsung,pin-con-pdn = <1>; /*OUT1*/
		samsung,pin-pud-pdn = <PIN_PULL_NONE>;
	};

	ese_spi_bus: ese_spi_bus {
		samsung,pins = SEC_GPIO(AP,gpp1,gpp1,0), SEC_GPIO(AP,gpp1,gpp1,1), SEC_GPIO(AP,gpp1,gpp1,2);
		samsung,pin-function = <2>;
		samsung,pin-pud = <PIN_PULL_NONE>;
		samsung,pin-drv = <PIN_AP_DRV_LV1>;
	};

	ese_spi_cs: ese_spi_cs {
		samsung,pins = SEC_GPIO(AP,gpp1,gpp1,3);
		samsung,pin-function = <1>;
		samsung,pin-pud = <PIN_PULL_NONE>;
		samsung,pin-drv = <PIN_AP_DRV_LV1>;
	};
};

&spi_1 {
	status = "ok";
	pinctrl-names = "ese_active", "ese_suspend";
	pinctrl-0 = <&ese_spi_bus &ese_spi_cs>;
	pinctrl-1 = <&ese_spi_bus_suspend &ese_spi_cs_suspend>;

	ese_spi@0 {
#if defined(CONFIG_SEC_FACTORY_INTERPOSER) && 1
		status = "disabled";
#else
		status = "ok";
#endif
		compatible = "ese_p3";
		reg = <0>;
		spi-max-frequency = <7000000>;
#if 0
		check_ese = <SEC_GPIO_REF(${ese_check}) 0>;
		pinctrl-names = "default";
		pinctrl-0 = <&ese_check_default>;
#endif
		gpio-controller;
		#gpio-cells = <2>;
#if 0
		p3-vdd-supply = <&${ese_pvdd_ldo}>;
#endif
		ese_p3,cs-gpio = <SEC_GPIO_REF(AP,gpp1,gpp1,3) 0>;
		controller-data {
			samsung,spi-feedback-delay = <0>;
			samsung,spi-chip-select-mode = <0>;
		};
	};
};

#if 0
&${ese_pvdd_ldo} {
	regulator-name = "p3-vdd";
};
#endif

#if 0
/ {
	fragment@ese_platform {
		target-path = "/";
		__overlay__ {
			ese_platform {
#if defined(CONFIG_SEC_FACTORY_INTERPOSER) && 1
				status = "disabled";
#else
				status = "ok";
#endif
				compatible = "p3_platform";
			};
		};
	};
};
#endif
#endif

&pinctrl_1 {
	nfc_i2c_pull_none: nfc_i2c_pull_none {
		samsung,pins = SEC_GPIO(AP,gpm4,gpm4,0), SEC_GPIO(AP,gpm4,gpm4,1);
		samsung,pin-function = <2>;
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
		samsung,pin-pud = <PIN_PULL_NONE>;
		samsung,pin-pud-pdn = <PIN_PULL_NONE>;
	};

#if 0
	nfc_i2c_no_change: nfc_i2c_no_change {
		samsung,pins = SEC_GPIO(AP,gpm4,gpm4,0), SEC_GPIO(AP,gpm4,gpm4,1);
		samsung,pin-function = <2>;
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
	};
	nfc_i2c_pull_up: nfc_i2c_pull_up {
		samsung,pins = SEC_GPIO(AP,gpm4,gpm4,0), SEC_GPIO(AP,gpm4,gpm4,1);
		samsung,pin-function = <2>;
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
		samsung,pin-pud = <PIN_PULL_UP>;
		samsung,pin-pud-pdn = <PIN_PULL_UP>;
	};
#endif
};

#if 0
&${xclkout_parent} {
	xclkout: xclkout {
		samsung,pins = SEC_GPIO(${xclkout_gpio});
		samsung,pin-function = <2>;
		samsung,pin-pud = <PIN_PULL_NONE>;
	};

	xclkout_nc: xclkout_nc {
		samsung,pins = SEC_GPIO(${xclkout_gpio});
		samsung,pin-function = <0>;
		samsung,pin-pud = <PIN_PULL_DOWN>;
	};
};
#endif

&pinctrl_3 {
	nfc_firm: nfc_firm {
		GPIO_CONFIG_PUD_DRV(AP,gpf1,gpf1,1, FUNC_OUTPUT_LOW, PULL_NONE, DRV_LV3);
		samsung,pin-con-pdn = <3>; /* PIN_PDN_PREV */
		samsung,pin-pud-pdn = <PIN_PULL_NONE>;
	};

	nfc_firm_nc: nfc_firm_nc {
		GPIO_CONFIG_PUD_DRV(AP,gpf1,gpf1,1, FUNC_INPUT, PULL_DOWN, DRV_LV3);
	};
};

&s2mps28_2_gpio {
	nfc_en: nfc_en {
		GPIO_CONFIG_PUD_DRV(PM,s2mps28_2_gpio,gpio_s,4, FUNC_OUTPUT_LOW, PULL_NONE, DRV_LV3);
		samsung,pin-con-pdn = <3>; /* PIN_PDN_PREV */
		samsung,pin-pud-pdn = <PIN_PULL_NONE>;
	};

	nfc_en_nc: nfc_en_nc {
		GPIO_CONFIG_PUD_DRV(PM,s2mps28_2_gpio,gpio_s,4, FUNC_INPUT, PULL_DOWN, DRV_LV3);
	};
};

&pinctrl_0 {
	nfc_clk_req: nfc_clk_req {
		samsung,pins = SEC_GPIO(AP,gpa4,gpa4,0);
		samsung,pin-function = <2>;
		samsung,pin-pud = <PIN_PULL_DOWN>;
	};

	nfc_clk_req_nc: nfc_clk_req_nc {
		samsung,pins = SEC_GPIO(AP,gpa4,gpa4,0);
		samsung,pin-function = <0>;
		samsung,pin-pud = <PIN_PULL_DOWN>;
	};
};

#if 0
&${nfc_check_parent} {
	nfc_check: nfc_check {
		GPIO_CONFIG_PUD_DRV(${nfc_check}, FUNC_INPUT, PULL_NONE, DRV_LV3);
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
		samsung,pin-pud-pdn = <PIN_PULL_NONE>;
	};
};
#endif

&hsi2c_39 {
	#address-cells = <1>;
	#size-cells = <0>;

	status = "ok";
	clock-frequency = <400000>; /* for HSI2C */
	samsung,i2c-max-bus-freq = <400000>; /* for Normal HW I2C */
	samsung,reset-before-trans;
#if 0
	pinctrl-names = "default", "i2c_pull_up";
	pinctrl-0 = <&nfc_i2c_no_change>;
	pinctrl-1 = <&nfc_i2c_pull_up>;
#else
	pinctrl-names = "default";
	pinctrl-0 = <&nfc_i2c_pull_none>;
#endif
	sec_nfc: sec-nfc@27 {
#if defined(CONFIG_SEC_FACTORY_INTERPOSER) && 1
		status = "disabled";
#else
		status = "ok";
#endif
		compatible = "sec-nfc";
		reg = <0x27>;

		interrupts = <SEC_GPIO_NUM(AP,gpa2,gpa2,3) 0 0>;
		interrupt-parent = <SEC_GPIO_TYPE(AP,gpa2,gpa2,3)>;

		sec-nfc,ven-gpio = <SEC_GPIO_REF(PM,s2mps28_2_gpio,gpio_s,4) 0>;
		sec-nfc,firm-gpio = <SEC_GPIO_REF(AP,gpf1,gpf1,1) 0>;
		sec-nfc,irq-gpio = <SEC_GPIO_REF(AP,gpa2,gpa2,3) 0>;
#if 0
		sec-nfc,check_nfc = <SEC_GPIO_REF(${nfc_check}) 0>;
#endif
		sec-nfc,clk_req-gpio = <SEC_GPIO_REF(AP,gpa4,gpa4,0) 0xf>;
#if 1
		sec-nfc,coldreset-gpio = <SEC_GPIO_REF(AP,gpf1,gpf1,0) 0>;
#endif
		nfc_pvdd-supply = <&l16_reg>;

		sec-nfc,ldo_control;

#if 0
		sec-nfc,irq_all_trigger;
#endif
#if 0
		sec-nfc,eint_mode;
#endif
#if 0
		clocks = <&clock OSC_NFC>;
		clock-names = "oscclk_nfc";
		sec-nfc,nfc_ap_clk;
#endif
		sec-nfc,nfc_ic_type = "SEN6";

		pinctrl-names = "default", "nfc_nc";
		pinctrl-0 = <&nfc_en &nfc_firm &nfc_clk_req
#if 0
				&nfc_check
#endif
#if 0
				&xclkout
#endif
				>;
		pinctrl-1 = <&nfc_en_nc &nfc_firm_nc &nfc_clk_req_nc
#if 0
				&xclkout_nc
#endif
				>;
	};
};

&l16_reg {
	regulator-name = "nfc_pvdd";
};


/* #include "../input_s3908t_i2c.dtsi" */            /* From input_s3908t_i2c.py */
&pinctrl_0 {
	gpio_int_init: gpio_int_init {
		GPIO_CONFIG_PUD(AP,gpa1,gpa1,2, FUNC_INPUT_WAKEUP, PULL_NONE);
	};

	gpio_int_sleep: gpio_int_sleep {
		GPIO_CONFIG_PUD(AP,gpa1,gpa1,2, FUNC_INPUT, PULL_NONE);
	};
};


&hsi2c_46 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "ok";
	clock-frequency = <400000>;
	samsung,reset-before-trans;
	samsung,stop-after-trans;	/* LSI IC ONLY */
	tsp_synaptics_i2c: touchscreen@20 {
		status = "ok";
		compatible = "synaptics,s3908t";
		reg = <0x20>;
		pinctrl-names = "on_state", "off_state";
		pinctrl-0 = <&gpio_int_init>;
		pinctrl-1 = <&gpio_int_sleep>;
		tsp_io_ldo-supply = <&l9_reg>;
		tsp_avdd_ldo-supply = <&l18_reg>;
		sec,irq_gpio = <SEC_GPIO_REF(AP,gpa1,gpa1,2) 0>;
		sec,ss_touch_num = <1>;

		sec,max_coords = <4096 4096>; /* x y */
	};
};


/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/input/sec_input_2024/touchscreen/synaptics/s3908t/dts_i2c/input-lsi-tsp-synaptics.r12s.dtsi */
&tsp_synaptics_i2c {
	sec,area-size = <133 266 341>; /* indicator: 24dp navigator:48dp edge:60px dpi=320 */

	sec,tclm_level = <2>;
	sec,afe_base = <0x0007>;
	support_dex_mode;
	support_mis_calibration_test;
	support_ear_detect_mode;
	support_open_short_test;
	support_vbus_notifier;
	support_refresh_rate_mode;
	enable_settings_aot;
	support_fod;
	support_fod_lp_mode;
	sec,firmware_name = "tsp_synaptics/s3908t_r12s.bin";
	sec,bringup = <0>;
	synaptics,tcm_drv_name = "synaptics_tcm_i2c";
	synaptics,tcm_dev_name = "tcm_i2c";
	synaptics,fw_delay = <0 0>; /* erase_delay, write_block_delay */
	synaptics,support_immediate_cmd;
	sec,enable_sysinput_enabled;
	sec,bitmask_unload = <0xFFFF00 0x804000>; /* bitshift bitmask. this is for goodix panel */

	sec_cmd,not_support_cmds = "rawdata_init";
	work_queue_probe_enabled;
};

&hsi2c46_bus {
	samsung,pin-con-pdn = <3>;
	samsung,pin-pud-pdn = <3>;
};


/* #include "../battery_common.dtsi" */              /* From battery_common.py */
#include <dt-bindings/battery/sec-battery.h>

&smd {
	sec_battery: battery {
		status = "okay";
		compatible = "samsung,sec-battery";
		battery,vendor = "Battery";
		battery,charger_name = "sec-direct-charger";
		battery,fuelgauge_name = "max77775-fuelgauge";
		battery,technology = <2>; /* POWER_SUPPLY_TECHNOLOGY_LION */
		battery,chip_vendor = "NONE";

		battery,batt_data_version = <1>;

		battery,adc_check_count = <5>;
		battery,temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;
		battery,usb_temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;
		battery,chg_temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;
		battery,wpc_temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;
		battery,lrp_temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;

		battery,thermal_source = <SEC_BATTERY_THERMAL_SOURCE_NONE>; /* SEC_BATTERY_THERMAL_SOURCE_NONE */
		battery,usb_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_NONE>; /* SEC_BATTERY_THERMAL_SOURCE_NONE */
		battery,chg_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_NONE>; /* SEC_BATTERY_THERMAL_SOURCE_NONE */
		battery,wpc_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_NONE>; /* SEC_BATTERY_THERMAL_SOURCE_NONE */

		battery,inbat_ocv_type =  <SEC_BATTERY_OCV_NONE>;

		battery,polling_time = <10 30 30 30 3600>;

		battery,cable_check_type = <SEC_BATTERY_CABLE_CHECK_PSY>;
		battery,cable_source_type = <SEC_BATTERY_CABLE_SOURCE_EXTERNAL>;
		battery,polling_type = <SEC_BATTERY_MONITOR_ALARM>; /* SEC_BATTERY_MONITOR_ALARM */
		battery,monitor_initial_count = <0>;

		battery,battery_check_type = <0>; /* SEC_BATTERY_CHECK_NONE */

		battery,ovp_uvlo_check_type = <SEC_BATTERY_OVP_UVLO_CHGPOLLING>; /* SEC_BATTERY_OVP_UVLO_CHGPOLLING */

		battery,temp_check_count = <1>;

		battery,usb_protection_temp = <610>;
		battery,temp_gap_bat_usb = <200>;
		battery,overheatlimit_threshold = <700>;
		battery,overheatlimit_recovery = <680>;
		battery,wire_warm_overheat_thresh = <500>;
		battery,wire_normal_warm_thresh = <420>;
		battery,wire_cool1_normal_thresh = <180>;
		battery,wire_cool2_cool1_thresh = <150>;
		battery,wire_cool3_cool2_thresh = <50>;
		battery,wire_cold_cool3_thresh = <0>;
		battery,wireless_warm_overheat_thresh = <500>;
		battery,wireless_normal_warm_thresh = <420>;
		battery,wireless_cool1_normal_thresh = <180>;
		battery,wireless_cool2_cool1_thresh = <150>;
		battery,wireless_cool3_cool2_thresh = <50>;
		battery,wireless_cold_cool3_thresh = <0>;
		battery,tx_high_threshold = <500>;
		battery,tx_high_recovery = <450>;
		battery,tx_low_threshold = <0>;
		battery,tx_low_recovery = <50>;

		battery,wire_warm_current = <1573>;	/* 0.36C */
		battery,wire_cool1_current = <3146>;	/* 0.72C */
		battery,wire_cool2_current = <1048>;	/* 0.24C */
		battery,wire_cool3_current = <437>;	/* 0.1C */
		battery,wireless_warm_current = <1048>;		/* 0.24C */
		battery,wireless_cool1_current = <3146>;	/* 0.72C */
		battery,wireless_cool2_current = <1048>;	/* 0.24C */
		battery,wireless_cool3_current = <437>;		/* 0.1C */

		battery,full_check_type = <SEC_BATTERY_FULLCHARGED_CHGPSY>;
		battery,full_check_type_2nd = <SEC_BATTERY_FULLCHARGED_CHGPSY>;
		battery,full_check_count = <1>;
		battery,chg_gpio_full_check = <0>;
		battery,chg_polarity_full_check = <1>;

		battery,chg_high_temp = <470>;
		battery,chg_high_temp_recovery = <450>;
		battery,chg_input_limit_current = <1000>;
		battery,chg_charging_limit_current = <1900>;

		battery,dchg_high_temp = <520>;
		battery,dchg_high_temp_recovery = <460>;
		battery,dchg_high_batt_temp = <400>;
		battery,dchg_high_batt_temp_recovery = <380>;
		battery,dchg_input_limit_current = <1000>;
		battery,dchg_charging_limit_current = <2000>;

		battery,wpc_temp_control_source = <TEMP_CONTROL_SOURCE_BAT_THM>;
		battery,wpc_high_temp = <400>;
		battery,wpc_high_temp_recovery = <380>;
		battery,wpc_input_limit_current = <800>;
		battery,wpc_charging_limit_current = <1000>;
		battery,wpc_temp_lcd_on_control_source = <TEMP_CONTROL_SOURCE_BAT_THM>;
		battery,wpc_lcd_on_input_limit_current = <800>;

		battery,wpc_store_high_temp = <360>;
		battery,wpc_store_high_temp_recovery = <340>;
		battery,wpc_store_charging_limit_current = <400>;
		battery,wpc_store_lcd_on_high_temp = <360>;
		battery,wpc_store_lcd_on_high_temp_rec = <300>;
		battery,wpc_store_lcd_on_charging_limit_current = <400>;

		battery,fcc_by_tx = <1200>;

		battery,sleep_mode_limit_current = <800>;
		battery,wc_full_input_limit_current = <100>;

		battery,ta_alert_wa;

		battery,mix_high_temp = <420>;
		battery,mix_high_chg_temp = <500>;
		battery,mix_high_temp_recovery = <390>;

		/* battery,usb_conn_slope_avg = <9>; */

		/* battery,enable_mix_v2; */
		/* if you want to use mix_v2 concept, add "battery,enable_mix_v2;" */
		battery,mix_v2_lrp_recov = <460>;
		battery,mix_v2_lrp_cond = <480>;
		battery,mix_v2_bat_cond = <480>;
		battery,mix_v2_chg_cond = <0>;	/* 0 means no use chg thm condition */
		battery,mix_v2_dchg_cond = <0>; /* 0 means no use dchg thm condition */

		battery,full_condition_type = <(SEC_BATTERY_FULL_CONDITION_NOTIMEFULL | SEC_BATTERY_FULL_CONDITION_VCELL)>;
		battery,full_condition_soc = <93>;
		/* battery,full_condition_vcell = FV - 50mV set when variable is parsed */

		battery,recharge_check_count = <1>;
		battery,recharge_condition_type = <SEC_BATTERY_RECHARGE_CONDITION_VCELL>;
		battery,recharge_condition_soc = <98>;
		/* battery,recharge_condition_vcell = FV - 70mV set when variable is parsed */

		battery,charging_reset_time = <0>;

		battery,chg_float_voltage = <4350>;

		battery,pre_afc_work_delay = <2000>;
		battery,pre_wc_afc_work_delay = <4000>;
		battery,pre_afc_input_current = <500>;
		battery,pre_wc_afc_input_current = <500>;

		battery,swelling_high_rechg_voltage = <4000>;
		/*battery,swelling_low_rechg_voltage = FV - 150mA set when variable is parsed */

		battery,siop_icl = <1200>;
		battery,siop_fcc = <1800>;
		battery,siop_hv_icl = <700>;
		battery,siop_hv_icl_2nd = <550>;
		battery,siop_hv_fcc = <1800>;
		battery,siop_apdo_icl = <1000>;
		battery,siop_apdo_fcc = <2000>;

		battery,siop_wpc_icl = <600>;
		battery,siop_wpc_fcc = <1000 500 100>; /* siop_level 70 10 0 */
		battery,siop_hv_wpc_icl = <700>;
		battery,siop_hv_wpc_fcc = <1000 500 100>; /* siop_level 70 10 0 */
		battery,siop_store_hv_wpc_icl = <450>;
		battery,store_mode_buckoff;

		/* trig, recov */
		battery,temp_table_LRP_45W = <385 365>;

		battery,rp_current_rp1 = <500>;
		battery,rp_current_rp2 = <1500>;
		battery,rp_current_rp3 = <3000>;
		battery,rp_current_rdu_rp3 = <2100>;
		battery,rp_current_abnormal_rp3 = <1800>;

		battery,pd_charging_charge_power = <15000>;
		battery,max_charging_current = <2350>;

		battery,store_mode_charging_max = <70>;
		battery,store_mode_charging_min = <60>;

		battery,wireless_cc_cv = <85>;
		battery,wireless_otg_input_current = <900>;

		/* Calculate Based on Offsets from float voltage, full_condition_vcell and recharge_condition_vcell */
		/* if you want to use age_data_by_common_offset concept add battery,age_data_by_common_offset; */

		battery,age_data_cycle = <0 300 400 700 1000>;
		battery,age_data_full_condition_soc = <93 92 91 90 89>;
		battery,age_data_common_offset = <0 20 40 110>;
		/* battery,age_data_max_charging_current_offset = <0 100 200 300 400>; */

		/* cycle, chg_float_voltage, recharge_condition_vcell, full_condition_vcell, full_condition_soc, step charging condition */
		battery,age_data = <0 4350 4280 4250 93
			300 4330 4260 4230 92
			400 4310 4240 4210 91
			700 4290 4220 4190 90
			1000 4240 4170 4140 89>;


		battery,health_condition_cycle = <900 1200 1500>;
		battery,health_condition_asoc = <0 0 0>; /* Default ASOC Disabled */

		battery,max_input_voltage = <9000>; /* mV */
		battery,max_input_current = <3000>;  /* mA */

		battery,cisd_alg_index = <8>;
		battery,cisd_max_voltage_thr = <4400>; /* batttery ovp dettection voltage */
		battery,ignore_cisd_index = <0 0>;
		battery,ignore_cisd_index_d = <0 80>; /* Do not use BUCK_OFF_PER_DAY, DROP_SENSOR_PER_DAY */

		battery,expired_time = <10800>;
		battery,recharging_expired_time = <5400>;

		battery,battery_full_capacity = <3300>;

		battery,ttf_capacity = <3500>;
		battery,cv_data = <
				3228	864	1534
				3133	866	1524
				3067	872	1493
				3019	874	1483
				2929	879	1452
				2896	881	1442
				2843	883	1431
				2792	885	1421
				2754	887	1411
				2695	892	1380
				2660	893	1370
				2625	895	1360
				2580	897	1349
				2531	898	1339
				2492	902	1319
				2450	903	1309
				2410	905	1298
				2348	908	1278
				2296	909	1268
				2263	910	1257
				2214	915	1227
				2182	916	1216
				2147	919	1196
				2103	920	1186
				2051	922	1175
				2019	924	1155
				1981	927	1134
				1948	928	1124
				1911	930	1104
				1879	932	1093
				1834	933	1083
				1795	935	1063
				1761	938	1032
				1722	942	1001
				1689	944	981
				1649	946	960
				1592	948	940
				1532	950	919
				1493	954	878
				1462	955	868
				1410	958	827
				1362	959	817
				1338	960	807
				1291	964	756
				1264	968	715
				1237	968	704
				1213	969	694
				1169	974	633
				1127	975	622
				1105	975	612
				1073	980	541
				1049	982	510
				1010	983	489
				993	984	479
				972	986	448
				955	988	407
				932	990	387
				881	990	377
				864	996	356
				761	1000	307
				710	1000	297
				688	1000	287
				668	1000	235
				658	1000	215
				647	1000	184
				635	1000	153
				622	1000	123
				610	1000	92
				596	1000	61
				583	1000	31
				571	1000	0
				>;

#if 1
		io-channels = <&s2mps27_gpadc 14>, <&s2mps27_gpadc 4>, <&s2mps27_gpadc 3>, <&s2mps27_gpadc 14>, <&s2mps27_gpadc 13>;
		io-channel-names = "adc-temp", "adc-chg-temp", "adc-in-bat", "adc-wpc-temp", "adc-usb-temp", "n/a", "n/a", "n/a";
#endif
#if 0
	/*EUR_DETECTION_NODE*/
	battery,eur_detection = <SEC_GPIO_REF(${eur_detection}) 0 >;
#endif
	};

	/* sec_battery_cable
	 *   0	UNKNOWN,
	 *   1	NONE,
	 *   2	PREPARE_TA,
	 *   3	TA,
	 *   4	USB,
	 *   5	USB_CDP,
	 *   6	9V_TA,
	 *   7	9V_ERR,
	 *   8	9V_UNKNOWN,
	 *   9	12V_TA,
	 *  10	WIRELESS,
	 *  11	HV_WIRELESS,
	 *  12	PMA_WIRELESS,
	 *  13	WIRELESS_PACK,
	 *  14	CABLE_WIRELESS_HV_PACK,
	 *  15	WIRELESS_STAND,
	 *  16	WIRELESS_HV_STAND,
	 *  17	QC20,
	 *  18	QC30,
	 *  19	PDIC,
	 *  20	UARTOFF,
	 *  21	OTG,
	 *  22	LAN_HUB,
	 *  23	POWER_SHARING,
	 *  24	HMT_CONNECTED,
	 *  25	HMT_CHARGE,
	 *  26	HV_TA_CHG_LIMIT,
	 *  27	WIRELESS_VEHICLE,
	 *  28	WIRELESS_HV_VEHICLE,
	 *  29	PREPARE_WIRELESS_HV,
	 *  30  TIMEOUT,
	 *  31  SMART_OTG,
	 *  32  SMART_NOTG,
	 *  33  WIRELESS_TX,
	 *  34	HV_WIRELESS_20,
	 *  35	HV_WIRELESS_20_LIMIT,
	 *  36	WIRELESS_FAKE,
	 *  37  PREPARE_WIRELESS_20,
	 *  38	CABLE_PDIC_APDO,
	 *  39  CABLE_POGO,
	 *  40  CABLE_POGO_9V,
	 *  41  FPDO_DC,
	 *  42	CABLE_MAX,
	 */
	sec_battery_cable: cable-info {
		default_input_current = <1800>;
		default_charging_current = <2100>;
		full_check_current_1st = <350>;
		full_check_current_2nd = <200>;

		current_group_1 {
			cable_number = <
				SEC_BATTERY_CABLE_PREPARE_TA
				SEC_BATTERY_CABLE_PDIC
				SEC_BATTERY_CABLE_OTG
				SEC_BATTERY_CABLE_LAN_HUB
				SEC_BATTERY_CABLE_POWER_SHARING>;
			input_current = <500>;
			charging_current = <500>;
		};
		current_group_2 {
			cable_number = <
				SEC_BATTERY_CABLE_HMT_CHARGE
				SEC_BATTERY_CABLE_SMART_OTG>;
			input_current = <1000>;
			charging_current = <1000>;
		};
		current_group_3 {
			cable_number = <
				SEC_BATTERY_CABLE_USB_CDP
				SEC_BATTERY_CABLE_SMART_NOTG>;
			input_current = <1500>;
			charging_current = <1500>;
		};
		current_group_4 {
			cable_number = <SEC_BATTERY_CABLE_9V_TA SEC_BATTERY_CABLE_9V_ERR
				SEC_BATTERY_CABLE_9V_UNKNOWN SEC_BATTERY_CABLE_QC20 SEC_BATTERY_CABLE_QC30>;
			input_current = <1650>;
			charging_current = <2350>;
		};
		current_group_5 {
			cable_number = <SEC_BATTERY_CABLE_12V_TA>;
			input_current = <1650>;
			charging_current = <2350>;
		};
		current_group_6 {
			cable_number = <
				SEC_BATTERY_CABLE_WIRELESS
				SEC_BATTERY_CABLE_PMA_WIRELESS
				SEC_BATTERY_CABLE_WIRELESS_STAND
				SEC_BATTERY_CABLE_WIRELESS_VEHICLE
				SEC_BATTERY_CABLE_WIRELESS_FAKE>;
			input_current = <800>;
			charging_current = <2350>;
		};
		current_group_7 {
			cable_number = <SEC_BATTERY_CABLE_WIRELESS_PACK>;
			input_current = <700>;
			charging_current = <2350>;
		};
		current_group_8 {
			cable_number = <SEC_BATTERY_CABLE_HMT_CONNECTED>;
			input_current = <1000>;
			charging_current = <450>;
		};
		current_group_9 {
			cable_number = <SEC_BATTERY_CABLE_HV_TA_CHG_LIMIT>;
			input_current = <1800>;
			charging_current = <1800>;
		};
		current_group_10 {
			cable_number = <
				SEC_BATTERY_CABLE_HV_WIRELESS
				SEC_BATTERY_CABLE_WIRELESS_HV_PACK
				SEC_BATTERY_CABLE_WIRELESS_HV_STAND
				SEC_BATTERY_CABLE_WIRELESS_HV_VEHICLE
				SEC_BATTERY_CABLE_HV_WIRELESS_20_LIMIT>;
			input_current = <650>;
			charging_current = <2350>;
		};
		current_group_11 {
			cable_number = <
				SEC_BATTERY_CABLE_PREPARE_WIRELESS_HV
				SEC_BATTERY_CABLE_PREPARE_WIRELESS_20>;
			input_current = <500>;
			charging_current = <1200>;
		};
		current_group_12 {
			cable_number = <
				SEC_BATTERY_CABLE_NONE
				SEC_BATTERY_CABLE_USB
				SEC_BATTERY_CABLE_TIMEOUT>;
			input_current = <475>;
			charging_current = <550>;
		};
		current_group_13 {
			cable_number = <SEC_BATTERY_CABLE_HV_WIRELESS_20>;
			input_current = <1200>;
			charging_current = <2350>;
		};
		current_group_14 {
			cable_number = <SEC_BATTERY_CABLE_WIRELESS_TX>;
			input_current = <800>;
			charging_current = <2350>;
		};
	};
	sec_battery_wireless_power_info: wireless-power-info {
		count = <9>;
		current_group_0 {
			wireless_power_class = <2>;
			vout = <9000>;
			input_current_limit = <830>;
			fast_charging_current = <3150>;
			ttf_charge_current = <1500>;
			rx_power = <7500>;
		};
		current_group_1 {
			wireless_power_class = <2>;
			vout = <10000>;
			input_current_limit = <750>;
			fast_charging_current = <3150>;
			ttf_charge_current = <1500>;
			rx_power = <7500>;
		};
		current_group_2 {
			wireless_power_class = <2>;
			vout = <11000>;
			input_current_limit = <680>;
			fast_charging_current = <3150>;
			ttf_charge_current = <1500>;
			rx_power = <7500>;
		};
		current_group_3 {
			wireless_power_class = <2>;
			vout = <12000>;
			input_current_limit = <625>;
			fast_charging_current = <3150>;
			ttf_charge_current = <1500>;
			rx_power = <7500>;
		};
		current_group_4 {
			wireless_power_class = <2>;
			vout = <9000>;
			input_current_limit = <1330>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2175>;
			rx_power = <12000>;
		};
		current_group_5 {
			wireless_power_class = <2>;
			vout = <11000>;
			input_current_limit = <1090>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2100>;
			rx_power = <12000>;
		};
		current_group_6 {
			wireless_power_class = <2>;
			vout = <12000>;
			input_current_limit = <1000>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2100>;
			rx_power = <12000>;
		};
		current_group_7 {
			wireless_power_class = <2>;
			vout = <11000>;
			input_current_limit = <1360>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2300>;
			rx_power = <15000>;
		};
		current_group_8 {
			wireless_power_class = <2>;
			vout = <12000>;
			input_current_limit = <1250>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2300>;
			rx_power = <15000>;
		};
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/battery/suwon/common/dts/r12s/battery_common.dtsi */
#include <dt-bindings/battery/sec-battery.h>

#define MAX_FV 4450
#define MAX_FCC 4189
#define WC_5V_ICL 700
#define WC_MAX_FCC 3286
#define DCHG_ICL 1000
#define DCHG_FCC 2000
#define STD_CURR 4350

#if 1
&pinctrl_0 {
	ovp_pwr_flagb_default: ovp_pwr_flagb_default {
			 GPIO_CONFIG_PUD_DRV(AP,gpa0,gpa0,2, FUNC_INPUT, PULL_UP, DRV_LV1);
		 };
};
#endif
#if 0
&${ovp_sig_flagb_parent} {
	ovp_sig_flagb_default: ovp_sig_flagb_default {
			 GPIO_CONFIG_PUD_DRV(${ovp_signal_gpio}, FUNC_INPUT, PULL_UP, DRV_LV1);
		 };
};
&ovp_sig_flagb_default {
	samsung,pin-con-pdn = <3>;
	samsung,pin-pud-pdn = <0>;
};
#endif
&smd {
	sec-cisd {
#if 1
		ovp_power = <SEC_GPIO_REF(AP,gpa0,gpa0,2) 0>; /* OVP_PWR_FLAGB */
#endif
#if 0
		ovp_signal = <SEC_GPIO_REF(${ovp_signal_gpio}) 0>; /* OVP_SIG_FLAGB */
#endif
	};

	sb_tx: sb-tx { aov {}; };
};

&sec_battery {

	pinctrl-names = "default";
	pinctrl-0 = <
#if 0
			&ovp_sig_flagb_default
#endif
#if 1
			&ovp_pwr_flagb_default
#endif
			>;

	battery,wireless_charger_name = "mfc-charger";

	battery,batt_data_version = <1>;

	battery,chip_vendor = "LSI";

	battery,temp_adc_type = <SEC_BATTERY_ADC_TYPE_AP>;
	battery,temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;
	battery,usb_temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;
	battery,chg_temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;
	battery,wpc_temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;
	battery,dchg_temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;
	battery,lrp_temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;

	battery,thermal_source = <SEC_BATTERY_THERMAL_SOURCE_ADC>;
	battery,usb_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_ADC>;
	battery,chg_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_ADC>;
	battery,wpc_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_ADC>;
	battery,dchg_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_CHG_ADC>;
	battery,dctp_by_cgtp;

	battery,temp_table_adc = <
		314 362 418 484 563
		655 759 886 1029 1191
		1371 1571 1783 2013 2245
		2481 2713 2933 3136 3311
		3466 3600 3701
		>;
	battery,temp_table_data = <
		900 850 800 750 700
		650 600 550 500 450
		400 350 300 250 200
		150 100 50 0 (-50)
		(-100) (-150) (-200)
		>;

	battery,usb_temp_table_adc = <
		286 334 392 461 541
		635 744 874 1019 1188
		1372 1576 1798 2030 2269
		2509 2742 2964 3167 3349
		3499 3630 3734
		>;
	battery,usb_temp_table_data = <
		900 850 800 750 700
		650 600 550 500 450
		400 350 300 250 200
		150 100 50 0 (-50)
		(-100) (-150) (-200)
		>;

	battery,chg_temp_table_adc = <
		256 302 357 423 496
		588 691 814 952 1113
		1291 1485 1701 1929 2161
		2401 2637 2864 3073 3255
		3421 3556 3670
		>;
	battery,chg_temp_table_data = <
		900 850 800 750 700
		650 600 550 500 450
		400 350 300 250 200
		150 100 50 0 (-50)
		(-100) (-150) (-200)
		>;

	battery,wpc_temp_table_adc = <
		314 362 418 484 563
		655 759 886 1029 1191
		1371 1571 1783 2013 2245
		2481 2713 2933 3136 3311
		3466 3600 3701
		>;
	battery,wpc_temp_table_data = <
		900 850 800 750 700
		650 600 550 500 450
		400 350 300 250 200
		150 100 50 0 (-50)
		(-100) (-150) (-200)
		>;

	battery,support_usb_conn_check;
	battery,usb_protection_temp = <500>;
	battery,temp_gap_bat_usb = <150>;

	battery,loosened_unknown_temp;
	battery,abnormal_wpc_check;
	
	battery,wire_cool3_cool2_thresh = <80>;
	battery,wireless_cool3_cool2_thresh = <80>;

	battery,wire_warm_current = <3286>;		/* 0.72C */
	battery,wire_cool1_current = <3286>;	/* 0.72C */
	battery,wire_cool2_current = <1095>;	/* 0.24C */
	battery,wire_cool3_current = <433>;		/* 0.1C + chargerIC tolerance MD75 ±5% */
	battery,wireless_warm_current = <WC_MAX_FCC>;	/* 0.72C */
	battery,wireless_cool1_current = <WC_MAX_FCC>;	/* 0.72C */
	battery,wireless_cool2_current = <1095>;	/* 0.24C */
	battery,wireless_cool3_current = <433>;		/* 0.1C + chargerIC tolerance MD75 ±5% */

	battery,full_check_type = <SEC_BATTERY_FULLCHARGED_FG_CURRENT>;
	battery,full_check_type_2nd = <SEC_BATTERY_FULLCHARGED_FG_CURRENT>;

	battery,chg_high_temp = <590>;
	battery,chg_high_temp_recovery = <530>;

	/* 45w pwr on, 45w pwr off, 25w pwr on, 25w pwr off */
	battery,dchg_high_temp = <1000 1000 730 590>;
	battery,dchg_high_temp_recovery = <1000 1000 670 530>;
	battery,dchg_high_batt_temp = <1000 1000 1000 400>; /* DISABLED */
	battery,dchg_high_batt_temp_recovery = <1000 1000 1000 390>; /* DISABLED */
	battery,dctp_bootmode_en;
	battery,dchg_dc_in_swelling;
	battery,fpdo_dc_charge_power = <22500>; /* 9V * 2.5A = 22.5W */

	battery,icl_by_tx_gear = <1100>;
	battery,fcc_by_tx_gear = <1400>;
	battery,fcc_by_tx = <800>;

	battery,standard_curr = <STD_CURR>;
	battery,expired_time = <9300>; /* 155 minutes */
	battery,recharging_expired_time = <5400>;

	battery,charging_reset_time = <0>;

	battery,max_charging_current = <MAX_FCC>;
	battery,max_charging_charge_power = <25000>; /* 25W */

	battery,chg_float_voltage = <MAX_FV>;
	battery,high_temp_float = <4200>;
	battery,low_temp_float = <MAX_FV>;
	battery,swelling_high_rechg_voltage = <4050>;
	battery,swelling_low_rechg_voltage = <4300>;
	battery,chgen_over_swell_rechg_vol;

	battery,chg_ocp_current = <0>;
	battery,chg_ocp_dtc = <100>;

	battery,enable_check_wpc_temp_v2;
	battery,wpc_high_temp = <410>;
	battery,wpc_high_temp_recovery = <400>;
	battery,wpc_temp_v2_cond = <390>;
	battery,wpc_input_limit_current = <800>;
	battery,wpc_charging_limit_current = <WC_MAX_FCC>;

	battery,enable_mix_v2;
	battery,mix_v2_lrp_recov = <440>;
	battery,mix_v2_lrp_cond = <460>;
	battery,mix_v2_bat_cond = <480>;
	battery,mix_v2_chg_cond = <0>;
	battery,mix_v2_dchg_cond = <0>;

	battery,siop_hv_icl = <675>;
	battery,siop_hv_wpc_icl = <500>;
	battery,rechg_hv_wpc_icl = <300>;

	battery,siop_scenarios = <20 0>;
	battery,siop_curr_type_num = <3>;
	/* nv, hv, fpdo */
	battery,siop_icl_20 = <1000 1000 1000>;
	battery,siop_fcc_20 = <SIOP_DEFAULT SIOP_DEFAULT SIOP_DEFAULT>;
	battery,siop_icl_0 = <SIOP_DEFAULT SIOP_DEFAULT SIOP_DEFAULT>;
	battery,siop_fcc_0 = <100 100 100>;

	battery,battery_full_capacity = <4700>;

	/* trig_step2_LCD_OFF, recov_step2_LCD_OFF, trig_step1_LCD_OFF , recov_step1_LCD_OFF,
	   trig_step2_LCD_ON, recov_step2_LCD_ON, trig_step1_LCD_ON , recov_step1_LCD_ON,
	   st1_icl, st1_fcc, st2_icl, st2_fcc */
	battery,temp_table_LRP_NORMAL = <
						390 380 380 370
						390 380 380 370
						1000 2000 1200 1800>;
	battery,temp_table_LRP_25W = <
						410 400 376 366
						400 390 376 366
						1700 3400 1100 2200>;

	/* cycle, full_condition_soc, common_offset */
	battery,age_data_by_common_offset; /* Calculate Based on Common Offset */
	battery,age_data_cycle = <0 200 250 300 1001>;
	battery,age_data_full_condition_soc = <93 92 91 90 89>;
	battery,age_data_common_offset = <0 20 40 60 110>;
	battery,en_batt_full_status_usage;

	battery,health_condition_asoc = <75 65 55>;

	/* step charging option */
	battery,step_chg_type = <0>;

	/* direct step charging option */
	battery,dc_step_chg_cond_v_margin = <10>;
	battery,dc_step_chg_type = <0x2A9 0x2A9>;
	battery,dc_step_chg_charge_power = <22000>;
	battery,dc_step_chg_step = <2>;
	battery,dc_step_chg_cond_vol = <4280 MAX_FV>;
	battery,dc_step_chg_val_vfloat = <4280 MAX_FV>;
	battery,dc_step_chg_val_iout = <5540 STD_CURR>;
	battery,dc_step_chg_vol_offset = <0 0>;
	battery,dc_step_chg_cond_iin = <2175 0>;
	battery,dc_step_chg_iin_check_cnt = <3>;
	battery,dc_step_chg_cond_soc = <64 100
					64 100
					64 100
					64 100>;

	battery,dis_auto_shipmode_temp_ctrl;
	battery,boosting_voltage_aicl;

	battery,cisd_max_voltage_thr = <4520>; /* battery ovp detection voltage */
	battery,cisd_alg_index = <8>;
	battery,ignore_cisd_index = <0 0>;
	battery,ignore_cisd_index_d = <0 80>; /* Do not use BUCK_OFF_PER_DAY, DROP_SENSOR_PER_DAY */

	battery,tx_stop_capacity = <30>;
	battery,tx_minduty_default = <20>;
	battery,tx_minduty_5V = <50>;

	battery,tx_uno_iout = <1500>;
	battery,tx_uno_iout_gear = <2000>;
	battery,tx_uno_iout_aov_gear = <1500>;
	battery,tx_mfc_iout_gear = <1500>;
	battery,tx_mfc_iout_aov_gear = <900>;
	battery,tx_mfc_iout_phone = <1100>;
	battery,tx_mfc_iout_phone_5v = <300>;
	battery,tx_mfc_iout_lcd_on = <900>;

	battery,tx_5v_disable;
	battery,phm_vout_ctrl_dev = <SEC_WIRELESS_PHM_VOUT_CTRL_BUDS>;

	battery,nv_wc_headroom = <WIRELESS_VRECT_ADJ_OFF>;

	battery,wpc_vout_ctrl_lcd_on;
	battery,wpc_flicker_wa_input_limit_current = <500>;
	battery,wpc_warm_fod;
	battery,max_wlc_icl_15w = <1200>;

	battery,support_spsn_ctrl;

	battery,ttf_capacity = <4606>;
	battery,ttf_hv_charge_current = <3108>;
	battery,ttf_dc25_charge_current = <4838>;
	battery,ttf_wireless_charge_current = <990>;
	battery,ttf_hv_wireless_charge_current = <1602>;
	battery,ttf_wc20_wireless_charge_current = <2331>;
	battery,ttf_wc21_wireless_charge_current = <3108>;

	battery,cv_data = <
		4214	830	1899
		3693	850	1827
		3103	870	1724
		2499	890	1600
		2013	910	1456
		1449	930	1249
		996	950	971
		862	970	473
		530	990	122
		477	1000	0
		>;
};

&sec_battery_cable {
	default_input_current = <1800>;
	default_charging_current = <2100>;
	full_check_current_1st = <456>;
	full_check_current_2nd = <228>;

	current_group_1 {
		cable_number = <
			SEC_BATTERY_CABLE_PREPARE_TA
			SEC_BATTERY_CABLE_PDIC
			SEC_BATTERY_CABLE_OTG
			SEC_BATTERY_CABLE_LAN_HUB
			SEC_BATTERY_CABLE_POWER_SHARING
			SEC_BATTERY_CABLE_TIMEOUT>;
		input_current = <500>;
		charging_current = <500>;
	};
	current_group_2 {
		cable_number = <
			SEC_BATTERY_CABLE_HMT_CHARGE
			SEC_BATTERY_CABLE_SMART_OTG>;
		input_current = <1000>;
		charging_current = <1000>;
	};
	current_group_3 {
		cable_number = <
			SEC_BATTERY_CABLE_USB_CDP
			SEC_BATTERY_CABLE_SMART_NOTG>;
		input_current = <1500>;
		charging_current = <1500>;
	};
	current_group_4 {
		cable_number = <
			SEC_BATTERY_CABLE_9V_TA
			SEC_BATTERY_CABLE_9V_ERR
			SEC_BATTERY_CABLE_9V_UNKNOWN>;
		input_current = <1650>;
		charging_current = <MAX_FCC>;
	};
	current_group_5 {
		cable_number = <SEC_BATTERY_CABLE_12V_TA>;
		input_current = <1650>;
		charging_current = <MAX_FCC>;
	};
	current_group_6 {
		cable_number = <
			SEC_BATTERY_CABLE_WIRELESS
			SEC_BATTERY_CABLE_PMA_WIRELESS
			SEC_BATTERY_CABLE_WIRELESS_STAND
			SEC_BATTERY_CABLE_WIRELESS_VEHICLE
			SEC_BATTERY_CABLE_HV_WIRELESS_20_LIMIT
			SEC_BATTERY_CABLE_WIRELESS_EPP_NV>;
		input_current = <800>;
		charging_current = <WC_MAX_FCC>;
	};
	current_group_7 {
		cable_number = <SEC_BATTERY_CABLE_WIRELESS_PACK>;
		input_current = <WC_5V_ICL>;
		charging_current = <WC_MAX_FCC>;
	};
	current_group_8 {
		cable_number = <SEC_BATTERY_CABLE_HMT_CONNECTED>;
		input_current = <1000>;
		charging_current = <450>;
	};
	current_group_9 {
		cable_number = <SEC_BATTERY_CABLE_HV_TA_CHG_LIMIT>;
		input_current = <2000>;
		charging_current = <1800>;
	};
	current_group_10 {
		cable_number = <
			SEC_BATTERY_CABLE_HV_WIRELESS
			SEC_BATTERY_CABLE_WIRELESS_HV_PACK
			SEC_BATTERY_CABLE_WIRELESS_HV_STAND
			SEC_BATTERY_CABLE_WIRELESS_HV_VEHICLE>;
		input_current = <750>;
		charging_current = <WC_MAX_FCC>;
	};
	current_group_11 {
		cable_number = <
			SEC_BATTERY_CABLE_PREPARE_WIRELESS_HV
			SEC_BATTERY_CABLE_WIRELESS_FAKE
			SEC_BATTERY_CABLE_PREPARE_WIRELESS_20>;
		input_current = <500>;
		charging_current = <1400>;
	};
	current_group_12 {
		cable_number = <
			SEC_BATTERY_CABLE_NONE
			SEC_BATTERY_CABLE_USB>;
		input_current = <475>;
		charging_current = <550>;
	};
	current_group_13 {
		cable_number = <
			SEC_BATTERY_CABLE_HV_WIRELESS_20
			SEC_BATTERY_CABLE_WIRELESS_EPP_FAKE
			SEC_BATTERY_CABLE_WIRELESS_EPP>;
		input_current = <400>;
		charging_current = <WC_MAX_FCC>;
	};
	current_group_14 {
		cable_number = <SEC_BATTERY_CABLE_WIRELESS_TX>;
		input_current = <WC_5V_ICL>;
		charging_current = <WC_MAX_FCC>;
	};
};

/* #include "../cps4038_charger.dtsi" */             /* From cps4038_charger.py */
#include <dt-bindings/battery/sec-battery.h>

&smd {
	sb_tx: sb-tx {
	       aov {
		       high_freq = <144>;
	       };
       };
};

&pinctrl_0 {
	cps_irq_default: cps_irq_default {
		GPIO_CONFIG_PUD_DRV(AP,gpa2,gpa2,4, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
	};
};

&pinctrl_0 {
	cps_det_default: cps_det_default {
		GPIO_CONFIG_PUD(AP,gpa1,gpa1,5, FUNC_INPUT_WAKEUP, PULL_NONE);
	};
};

&s2mps28_2_gpio {
	cps_en_default: cps_en_default {
		GPIO_CONFIG_PUD(PM,s2mps28_2_gpio,gpio_s,5, FUNC_OUTPUT_LOW, PULL_NONE);
	};
};

#if 1
&pinctrl_0 {
	cps_pdrc_default: cps_pdrc_default {
		GPIO_CONFIG_PUD(AP,gpa3,gpa3,2, FUNC_INPUT_WAKEUP, PULL_NONE);
	};
};
#endif

#if 1
&pinctrl_1 {
	cps_ping_nen_default: cps_ping_nen_default {
		GPIO_CONFIG_PUD(AP,gpm13,gpm13,0, FUNC_OUTPUT_HIGH, PULL_NONE);
	};
};
#endif

#if 1
&pinctrl_1 {
	cps_pdet_b_default: cps_pdet_b_default {
		GPIO_CONFIG_PUD(AP,gpm13,gpm13,1, FUNC_INPUT_WAKEUP, PULL_NONE);
	};
};
#endif

#if 1
&pinctrl_0 {
	cps_mag_det_default: cps_mag_det_default {
		GPIO_CONFIG_PUD(AP,gpa2,gpa2,7, FUNC_OUTPUT_HIGH, PULL_NONE);
	};
};
#endif

#if 0
&${wpc_mode_parent} {
	cps_wpc_mode_default: cps_wpc_mode_default {
		GPIO_CONFIG_PUD(${cps_wpc_mode_gpio}, FUNC_OUTPUT_HIGH, PULL_NONE);
	};
};
#endif

&hsi2c_45 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	clock-frequency = <100000>;

	cps4038_charger: cps4038-charger@38 {
		compatible = "cps,cps4038-charger";
		reg = <0x38>;
		status = "okay";

		pinctrl-names = "default";
		pinctrl-0 = <&cps_irq_default &cps_det_default &cps_en_default
#if 1
			&cps_pdrc_default
#endif
#if 1
			&cps_ping_nen_default
#endif
#if 1
			&cps_pdet_b_default
#endif
#if 1
			&cps_mag_det_default
#endif
#if 0
			&cps_wpc_mode_default
#endif
			>;

		battery,wpc_int = <SEC_GPIO_REF(AP,gpa2,gpa2,4) 1>; /* MFC_AP_INT */
		battery,wpc_det = <SEC_GPIO_REF(AP,gpa1,gpa1,5) 0>; /* WPC_DET */
#if 0
		battery,mst_pwr_en = <SEC_GPIO_REF(${cps_pwr_en_gpio}) 0>; /* MST_PWR_EN */
#endif
#if 1
		battery,wpc_ping_nen = <SEC_GPIO_REF(AP,gpm13,gpm13,0) 1>; /* PING_NEN */
#endif
#if 1
		battery,wpc_pdet_b = <SEC_GPIO_REF(AP,gpm13,gpm13,1) 1>; /* PDET_B */
#endif
		battery,wpc_en = <SEC_GPIO_REF(PM,s2mps28_2_gpio,gpio_s,5) 0>; /* WPC_EN */
#if 1
		battery,wpc_pdrc = <SEC_GPIO_REF(AP,gpa3,gpa3,2) 1>; /* VRECT_INT */
#endif
#if 1
		battery,wpc_mag_det = <SEC_GPIO_REF(AP,gpa2,gpa2,7) 0>; /* MAG_DET */
#endif
#if 0
		battery,wpc_mode = <SEC_GPIO_REF(${cps_wpc_mode_gpio}) 0>; /* WPC_MODE */
#endif

		battery,charger_name = "max77775-charger";
		battery,fuelgauge_name = "max77775-fuelgauge";
		battery,wireless_charger_name = "cps4038-charger";
		battery,wc_cover_rpp = <0x44>;
		battery,phone_fod_threshold = <0x3b>;
		battery,wireless20_vout_list = <WIRELESS_VOUT_9V /* 0xA0 */
						WIRELESS_VOUT_12V /* 0xA1 */
						WIRELESS_VOUT_12V /* 0xA2 */
						WIRELESS_VOUT_12V /* 0xA3 */
						WIRELESS_VOUT_12V /* 0xA4 */
						WIRELESS_VOUT_12V>; /* 0xA5 */
		battery,wireless20_vrect_list = <MFC_AFC_CONF_12V_TX
						MFC_AFC_CONF_12_5V_TX
						MFC_AFC_CONF_12_5V_TX
						MFC_AFC_CONF_12_5V_TX
						MFC_AFC_CONF_12_5V_TX
						MFC_AFC_CONF_12_5V_TX>;
		battery,wireless20_max_power_list = <SEC_WIRELESS_RX_POWER_12W
						SEC_WIRELESS_RX_POWER_15W
						SEC_WIRELESS_RX_POWER_15W
						SEC_WIRELESS_RX_POWER_15W
						SEC_WIRELESS_RX_POWER_15W
						SEC_WIRELESS_RX_POWER_15W>;

		battery,buds_fod_ta_thresh = <0x0898>; /* 2200mW */
		battery,wpc_vout_ctrl_full = <WIRELESS_VOUT_5V_STEP>;
		battery,mis_align_guide;
		battery,mis_align_target_vout = <5000>;
		battery,mpp_epp_vout = <WIRELESS_VOUT_12V>;

		fod_list {
			count = <1>;

			pad_0x00 { /* DEFAULT PAD */
				bpp { /* DEFAULT OP MODE */
					flag = <(SET_FOD_CC(ADD) | SET_FOD_CV(USE_CC) | SET_FOD_FULL(ADD))>;
					cc = <0x4E 0x0F 0x4E 0x10 0x4E 0x0C 0x4E 0x0C 0x4E 0x0C 0x4E 0x0C 0x4E 0x0D 0x4E 0x0D 0x4E 0x0D 0x4E 0x0D>;
					full = <0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F
						0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F>;
				};

				ppde {
					flag = <(SET_FOD_CC(USE_DEF_OP) | SET_FOD_CV(USE_DEF_OP) | SET_FOD_FULL(USE_DEF_OP))>;
				};

				epp {
					flag = <(SET_FOD_CC(USE_DEF_OP) | SET_FOD_CV(USE_DEF_OP) | SET_FOD_FULL(USE_DEF_OP))>;
				};

				mpp {
					flag = <(SET_FOD_CC(USE_DEF_OP) | SET_FOD_CV(USE_DEF_OP) | SET_FOD_FULL(USE_DEF_OP))>;
				};
			};
		};
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/battery/suwon/wireless/cps4038/cps4038_charger.r12s.dtsi */
#include <dt-bindings/battery/sec-battery.h>

&cps4038_charger {
	battery,unknown_cmb_ctrl;
	battery,pcr_fix_mode;
	battery,default_clamp_volt;
	battery,tx_max_op_freq = <1450>;
	battery,tx_min_op_freq = <1120>;
	battery,wireless20_iec_ploss_fod_enable = <0x1>;
	battery,tx_fod_gain = <0x72>;
	battery,buds_fod_thresh1 = <0x0DAC>;
	battery,buds_fod_ta_thresh = <0x0DAC>;
	battery,cep_timeout_xac = <900>;

	fod_list {
		epp_ref_qf = <0x26>;
		epp_ref_rf = <0x6C>;

		count = <1>;

		pad_0x00 { /* DEFAULT */
			bpp { /* DEFAULT OP MODE */
				flag = <(SET_FOD_CC(ADD) | SET_FOD_CV(ADD) | SET_FOD_FULL(ADD))>;
				cc = <0x4F 0x0E 0x4F 0x0E 0x4F 0x0B 0x4F 0x0B 0x4F 0x0B 0x4F 0x0B 0x4F 0x0B 0x4F 0x0B 0x4F 0x0B 0x4F 0x0B>;
				cv = <0x4F 0x16 0x4F 0x16 0x4F 0x13 0x4F 0x13 0x4F 0x13 0x4F 0x13 0x4F 0x13 0x4F 0x13 0x4F 0x13 0x4F 0x13>;
				full = <0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F 0xFF 0x7F>;
			};

			epp {
				flag = <(SET_FOD_CC(ADD) | SET_FOD_CV(ADD) | SET_FOD_FULL(USE_DEF_OP))>;
				cc = <0x5B 0x1C 0x5B 0x1C 0x5B 0x19 0x5B 0x17 0x5B 0x1B 0x5B 0x1B 0x5B 0x20 0x5B 0x20 0x5B 0x20 0x0E 0x03>;
				cv = <0x5B 0x24 0x5B 0x24 0x5B 0x21 0x5B 0x1F 0x5B 0x23 0x5B 0x23 0x5B 0x28 0x5B 0x28 0x5B 0x28 0x0E 0x03>;
			};

			ppde {
				flag = <(SET_FOD_CC(ADD) | SET_FOD_CV(ADD) | SET_FOD_FULL(USE_DEF_OP))>;
				cc = <0xA0 0x37 0xA0 0x37 0xA0 0x2F 0xA0 0x31 0xA0 0x31 0xA0 0x30 0xA0 0x2E 0xA0 0x2A 0xA0 0x28 0xA0 0x28>;
				cv = <0xA0 0x3F 0xA0 0x3F 0xA0 0x37 0xA0 0x39 0xA0 0x39 0xA0 0x38 0xA0 0x36 0xA0 0x32 0xA0 0x30 0xA0 0x30>;
			};
		};
	};
};

/* revision devicetree for general */
#include "s5e9945.r12s_eur_openx.04.dtsi"

/ {
	compatible = "SAMSUNG,R12S_EUR_OPENX","SAMSUNG,S5E9945";
	dtbo-hw_rev = <4>;
	dtbo-hw_rev_end = <7>;
};
